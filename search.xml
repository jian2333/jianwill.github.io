<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自用的前端小工具]]></title>
    <url>%2F2021%2F09%2F08%2Ffe-tools%2F</url>
    <content type="text"><![CDATA[最近要在项目里引入 git commit 前执行 eslint 校验，通过才允许提交的功能。考虑到可能会在多个项目中使用，以后也可能会增加其他功能。然后吧，决定写个小工具，集合了一键安装相关依赖的功能，后续只要不断维护小工具就能扩展功能了。目前的成果是，写了个包发布在 npm 上，通过命令 npx zwt-fe 即可使用。效果如下：想法一开始考虑到用户体验，最开始是打算使用类似 一键安装v2ray脚本 那种方式的，用户只需在 终端 输入命令，即可直接使用最新版的小工具，类似这样：1bash &lt;(curl -L -s https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install.sh) | tee v2ray_ins.log后来但是考虑到开发成本，一键安装脚本 要使用 shell 开发的，有一定的学习成本，而且有些功能(动效、替换内容等)实现比较麻烦，最后决定用 node 写了，发包到 npm 上，直接使用 npx xx 即可。eslint + husky提交代码 git commit 时自动调用 eslint 校验代码，通过才提交代码。输入 npm run lint:fix 调用 esilnt 自动修复相关错误。实现过程husky 可以捕获 git 的钩子，在 git commit 前的钩子 pre-commit 上添加 npm run lint 即可以实现。eslint配置安装依赖：npm install -D eslint@7.32.0 eslint-plugin-vue@7.16.0 eslint-loader@4.0.2 babel-eslint@10.1.0 。创建 .eslintrc.js 并写入：less xxx &gt; .eslintrc.js 。创建 .eslintignore 并写入：less xx &gt; .eslintignore 。package.json 的 script 中写入：npm run lint：npm set-script lint &quot;./node_modules/.bin/eslint --ext .js,.vue ./&quot; 。npm run lint:fix：npm set-script lint &quot;./node_modules/.bin/eslint --fix --ext .js,.vue ./&quot; 。npm set-script 需要 npm7 | node15 以上，版本不符合需自己写方法替换 。husky配置官方文档：https://typicode.github.io/husky/#/?id=features 。安装 husky7：npx husky-init &amp;&amp; npm install。【可选】新增其他钩子：npx husky add .husky/pre-commit &quot;npm test&quot;。修改命令 echo &quot;npm run lint&quot; &gt;&gt; ./husky/pre-commit 。【可选】添加 path环境变量(sourceTree用)：echo &quot;export PATH=\&quot;$(dirname $(which node)):\$PATH\&quot;&quot; &gt; ~/.huskyrc 。其他: node路径__dirname：node 命令所在文件的路径 。./xx：执行 node 命令时的路径 。特例：在 require(&#39;./xx&#39;)时，和 __dirname 一样，是所在文件的路径 。commitlint + git cz + changelog提交代码 git commit 时自动校验 commit message 的格式，符合Angular规范的才提交成功 。使用 git cz 或 git-cz 代替 git commit，用工作流的方式添加符合规范的 commit message 。根据 git log 自动生成 CHANGELOG.md，需要注意：npm run changelog: 在 CHANGELOG.md 内生成自上次 npm run changelog 后至 package.json.version 更新之间的 git 提交记录。只添加在最后，不覆盖文件。PS：所以，使用 npm run changelog 更新记录前，需手动修改 package.json 中的 version，或使用 npm version major|minor|patch 自动更新 package.json 中的 version。npm run changelog:all：在 CHANGELOG.md 内生成从项目创建开始到现在的 git 提交记录，会覆盖文件。实现过程commitlint配置安装依赖：npm install -D @commitlint/cli@13.1.0 @commitlint/config-conventional@13.1.0 。创建 commitlint.config.js 并写入：less xxx &gt; commitlint.config.js。【可选】安装 husky：已安装可忽略 npx husky-init &amp;&amp; npm install。添加钩子：npx husky add .husky/commit-msg &#39;npx --no-install commitlint --edit $1&#39;。【可选】测试效果：echo &quot;foo&quot; | ./node_modules/.bin/commitlint 。git-cz配置官方文档：https://github.com/streamich/git-cz 。官方文档：https://github.com/commitizen/cz-cli/blob/master/README.md 。commitizen 默认使用 cz-conventional-changelog，只能显示英文，如要显示中文需使用 git-cz 并修改配置文件 changelog.config.js 。安装 commitizen 和 git-cz：npm install -g commitizen git-cz。初始化 git-cz：commitizen init git-cz -D -E --force。创建 changlog.config.js 并写入：less xxx &gt; changelog.config.js。changelog配置安装依赖：npm install -D conventional-changelog-cli 。写入脚本到 package.json：changelog：npm set-script changelog &quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot;。changelog:all：npm set-script changelog:all &quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&quot;。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>cli</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021面试笔记]]></title>
    <url>%2F2021%2F06%2F02%2F2021-work%2F</url>
    <content type="text"><![CDATA[基础相关html-css盒模型margin、border、padding、contentbox-sizing: content-box(默认)、border-boxinline: &lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;block: &lt;div&gt;、&lt;p&gt;、&lt;h1&gt;-&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;inline-block: image、input居中水平：内联：text-align: center块元素：1234567891011121314151617181920212223// transform.son &#123; position: absolute; left: 50%; margin-left: - 1/2 width; // 或者 transform: translateY(-50%);&#125;// flex.father &#123; display: flex; justify-content: center;&#125;// 常规.son &#123; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto&#125;垂直内联：line-height: height块元素：1234567891011121314151617181920212223// transform.son &#123; position: absolute; top: 50%; margin-top: - 1/2 height; // 或者 transform: translateY(-50%)&#125;// flex.father &#123; display: flex; align-item: center;&#125;// 常规，同上.son &#123; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto&#125;完全：flexflex-direction: row, row-reserve, column, column-reserveflex-wrap: wrap, no-wrap, wrap-reserveflex-flow: flex-direction + flex-wrap 组合justify-content: flex-start, flex-end, center, space-between, space-aroundalign-content: stretch, flex-start, flex-end, center, space-between, space-aroundalign-items: stretch, flex-start, flex-end, center, baselinealign-self: auto, stretch, flex-start, flex-end, center, baselinegriddisplay: grid | inline-gridgrid-template-column, grid-template-row, grid-auto-column, grid-auto-rowrepeat, auto-fill / auto-fit, fr, minmax(), auto, 网格线的名字auto-fill: 完全填充时一样。不完全填充时，保留 原宽度不变auto-fit: 完全填充时一样。不完全填充时，会 拉伸原宽度至填充满grid-template-area: 区域，后面定位用grid-row-gap, grid-column-gap, grid-gap(row | column)grid-auto-flow: row, row dense, column, column dense位置容器，整体位置：justify-content, align-content, place-content(align | justify)start, end, center, stretch, space-around, space-between, space-evenly(等间距)容器，每个项目内元素位置justify-items, align-items, place-items, place-items(align | justify)start, end, center, stretch项目，每个项目内元素位置justify-self, align-self, place-self(align | justify)start, end, center, stretch合并grid-column-start, grid-column-end, grid-row-start, grid-row-end12345678910111213.item-1 &#123; grid-column-start: 1; grid-column-end: 2;&#125;// 等效于.item-2 &#123; grid-column-start: span 2;&#125;// 或者.item-3 &#123; grid-column-end: span 2;&#125;grid-column: grid-column-start / grid-column-endgrid-row: grid-row-start / grid-row-end对于 xx-end 也可用 span 表示跨越/ 后可省略，默认跨越1格123456789101112131415.item-1 &#123; grid-column: 1 / 3; // grid-column: 1 e("/") 3; // calc(~'50% - @&#123;bg&#125; - 10px')&#125;// 等效于.item-1 &#123; grid-column-start: 1; grid-column-end: 3;&#125;// 或者.item-1 &#123; grid-column: 1 / span 2;&#125;grid-area: 区域定位12345678.item-1 &#123; grid-area: e;&#125;// 等效于 .item-2 &#123; grid-area: 2 / 2 / 3 / 3&#125;使用 grid-template-area 的定位或者等效于 grid-area: grid-row-start / grid-column-start / grid-row-end / grid-column-end伪元素链接相关：link, visited, hover, active常用：first-childnth-child, nth-of-type, nth-col(odd: 奇数， even: 偶数)focus, not, has, rootbefore, after: 创建一个已选中元素的第x个子元素穿透穿透父级/高优先级样式/deep/>&gt;&gt;优先级7大优先级，内联style、id选择器、属性选择器、类选择器、伪类选择器、元素选择器、通用选择器(*)权重计算：1000、100、10*3、1*2不能跨层级backgroundcolor:image: url(‘xxx’)position: top, right bottom left centerrepeat: repeat, repeat-x, repeat-y, no-repeatattachment:local: 相对 元素内容 固定，会在子窗口中随滚动条滚动scroll: 相对 元素 固定，不会在子窗口中随滚动条滚动size: 固定值，百分比，cover, contain合并写法：url position / size repeat attachment color高级用法： linear-gradient: 渐变positionstatic, fixed, relative, absolute,sticky: 粘性定位，相对定位和固定定位的混合。在跨越特定阈值前为相对定位，之后为固定定位。需指定 top、right、bottom、left 4个值其中1个。js基础类型值类型：String、Number、Null、Undefined、Boolean保存在 栈 中引用类型：Object、Array、Date、Function变量名保存在 栈 中，变量值保存在 堆 中原型/原型链原型详解箭头函数不能用来继承，因为没有 prototype 属性原型原型，又叫原型对象，指构造函数的 prototype， 比如 Father.prototype原型的作用就是共享方法，Father.prototype.method 上的方法，可以被共享原型中的 this 指向实例原型链原型与原型之间相链接的过程即为 原型链实例的 __proto__ 指向的是构造函数的 protoType 原型对象: console(obj.__proto__ === Star.prototype) // true原型查找方式查找obj实例上是否有 dance 方式： this.dance = function(){}查找Star构造函数 原型对象 prototype 上是否有 dance 方法：Star.prototype.dance = xxx查找Object原型对象 prototype 上是否有 dance 方法：Object.prototype.dance = xxx还没找到，就报错原型构造器原型的构造器指向构造函数12console.log(Star.prototype.constructor === Star) // trueconsole.log(obj.__proto__.constructor === Star) // trueStar.prototype = {} 会丢失构造器，所以一般用 Star.prototype.xxx = function() {}继承call 只可以继承 属性，要继承 函数 的话，需要使用 原型链继承方法一：利用 Son.prototype = Father.prototype 改变原型指向，但子类增加原型方法，也会影响到父类123456789101112131415function Father(name) &#123; this.name = name&#125;Father.prototype.dance = function () &#123;..&#125;function Son(name, age) &#123; Father.call(this, name) this.age = age&#125;Son.prototype = Father.prototype// 为子类添加方法Son.prototype.sing = function () &#123;...&#125;let son = new Son('xiaohong', 18)// 此时父类也被影响了console.log(Father.prototype) // &#123;dance: f, sing: f, constructor: f&#125;console.log(Father) // f Father(name) &#123;&#125;方法二：子类的原型指向父类的实例 Son.prototype = new Father()， 这样就可以顺着原型链继承父类的方法了。并且子类添加原型方法的时候，不会影响父类1234567891011121314function Father(name) &#123; this.name = name&#125;Father.prototype.dance = function () &#123;...&#125;function Son(name, age) &#123; Father.call(this, name) this.age = age&#125;Son.prototype = new Father()Son.prototype.sing = function() &#123;...&#125;let son = new Son('xiaoming', 20)// 此时父类不受影响console.log(Father.prototype) // &#123;dance: f, constructor: f&#125;console.log(Son.prototype) // Father实例 &#123;name: undefined, sing: f, __proto__: &#123; dance: f, constructor: f &#125;&#125;继承的写法ES5写法：上面的原型链写法ES6写法： 类写法123456789101112131415class Father &#123; constructor(name) &#123; this.name = name &#125; dance() &#123;...&#125;&#125;class Son extends Father &#123; constructor(name, age) &#123; super(name) this.age = age &#125; sing() &#123;...&#125;&#125;let obj = new Son('xiaohong', 18)console.log(Father.prototype) // &#123;dance: f, constructor: f&#125;常用函数String: slice, toUpperCase, toLowerCase, indexOf, startsWith, endsWith,padStart, padEndArray: find, filter, map, includes, flat, reduce, slice, splice, concatreduce: (reducer, initialValue)reducer: (accumulator, currentValue, index, array)非变异方法(不改变现有数组): filter, slice, concatObject: keys, hasOwnproperty, valuesMap, Set: has, set, get, delete, entites正则表达式^$*+?{n, m}[^xyz]非贪婪匹配(?): (.*)(&amp;arr=(.))举例： 匹配url字符串方法一：12345678910function getValue (key) &#123; // 规则 ?|&amp;key=value|&amp;|$, 也就是 /(\?|&amp;)$&#123;key&#125;=([^&amp;]*)(&amp;|$)/ // (\?|&amp;): 以?或&amp; 开头 // ([^&amp;]*): 匹配非&amp;字符，贪婪匹配 // (&amp;|$): 以&amp;或最后字符结尾 let url = decodeURI(window.location.href) let reg = new RegExp(`(\\?|&amp;)$&#123;key&#125;=([^&amp;]*)(&amp;|$)`, 'i') let res = url.match(reg) return (res &amp;&amp; res.length &gt; 2) ? res[2] : ''&#125;方法二：12345678import qs from 'qs'function getValue2 (key) &#123; let search = window.location.href.split('?')[1] let params = qs.parse(search) console.log('params', params, params[key]) return params[key]&#125;,this普通函数普通函数调用: 全局windows作为对象的函数调用：上级对象作为构造函数调用：new 出来的对象call、apply: 传入的上下文箭头函数没有绑定this，它的this取决于该函数外部非箭头函数的this值setTimeout, setInterval普通函数：指向windows箭头函数：指向外层对象objbind,call,apply都是改变执行的上下文，也就是 this 的指向call, apply: 立即执行call: pa1, pa2, pa3, …apply: [pa1, pa2, pa3, …]bind: 只是生成一个新函数，在调用时才执行123456789Object.prototype.toString.call(null); // "[object Null]"Object.prototype.toString.call([]); // "[object Array]"Object.prototype.toString.call(&#123;&#125;); // "[object Object]"Object.prototype.toString.call(123); // "[object Number]"Object.prototype.toString.call('123'); // "[object String]"Object.prototype.toString.call(false); // "[object Boolean]"Object.prototype.toString.call(undefined); // "[object Undefined]"// 优化Object.prototype.toString.call([]).slice(8, -1); // Arraypromise、async、awaitpromise:new Promise, Promise.resolve, Promise.rejectthen, catchall: 全成功或1个失败，then/catch, 并行race: 1个成功或失败，then/catch, 并行allSettled: 全部成功或失败，then, [{status: ‘fulfilled’, value: ‘’}, {status: ‘rejected’, reason: ‘’}]async:返回 promiseawait:async 内部才能使用await 默认只能链式成功的promise，除非加 .catchfor、for of 内会按顺序执行，其他有回调循环的循环(forEach、filter、map、reduce)不会按顺序axios123456axios.carete(&#123; baseURL: '', timeout: 30000, token: '', headers: &#123;&#125;&#125;)123axios.interceptors.request.use(request =&gt; &#123; &#125;)123axios.interceptors.response.use(response =&gt; &#123; // response.data, code&#125;)添加请求参数get: axios.get(url, { params: {aa: 1, bb: 2} })post: axios.post(url, { aa: 1, bb: 2 })防止多次请求使用axiom.cancelToken = new Axios.CancelToken(function executor(cancel){ // 执行cancel })1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// request interceptorservice.interceptors.request.use( (config) =&gt; &#123; removePending(config, "请求前触发"); addPending(config); return config; &#125;, (error) =&gt; &#123; return Promise.reject(error); &#125;);const pendings = &#123;&#125;/** * 添加请求 */export let addPending = (config) =&gt; &#123; const &#123; method, url, params, data &#125; = config; const id = [method, url, JSON.stringify(params), JSON.stringify(data)].join('&amp;'); config.cancelToken = new Axios.CancelToken(function executor(cancel) &#123; if (!pendings[id]) &#123; pendings[id] = cancel &#125; &#125;) return config;&#125;/*** 移除请求*/export let removePending = (config) =&gt; &#123; if (!Object.keys(pendings).length) &#123; return &#125; // console.log(who, pendings, '取消前') let &#123; method, url, params, data &#125; = config; try &#123; data = JSON.parse(data) &#125; catch (error) &#123; // data &#125; const id = [method, url, JSON.stringify(params), JSON.stringify(data)].join('&amp;'); const cancel = pendings[id]; if (cancel &amp;&amp; typeof cancel === 'function') &#123; cancel(); delete pendings[id] &#125; // console.log(who, pendings, '取消后')&#125;/** * 清空所有pending请求 */export let clearPending = () =&gt; &#123; Object.keys(pendings).forEach(c =&gt; pendings[c]());&#125;防抖和节流防抖：执行高频函数n秒后才执行x函数，如果期间执行n，重新计时并结束后再执行x12345678910111213141516171819/** 1. 函数防抖* 执行高频函数x秒后才执行n函数* 场景：dom更新，onresize，input下拉框* */function debounce(fn) &#123; let timeout = null return function () &#123; clearTimeout(timeout) timeout = setTimeout(() =&gt; &#123; fn.call(this, arguments) &#125;, 300) &#125;&#125;function sayHi() &#123; console.log('say hi')&#125;let inp = document.getElementById('inp')inp.addEventListener('input', debounce(sayHi))节流：n秒内只执行一次x函数1234567891011121314151617181920212223/** 2. 函数节流* x秒内只执行一次n函数* 场景：api请求* */function throttle(fn) &#123; let canRun = true return function () &#123; if (!canRun) &#123; return &#125; canRun = false setTimeout(() =&gt; &#123; fn.call(this, arguments) canRun = true &#125;, 300) &#125;&#125;function sayH(e) &#123; console.log(e.target.innerWidth, e.target.innerHeight)&#125;window.addEventListener('resize', throttle(sayH))defer、asyncdefer: 异步下载，最后执行async: 异步下载，下载完执行捕获/冒泡事件有3个阶段：事件捕获阶段、事件目标阶段、事件冒泡阶段事件捕获阶段：父 –&gt; 子事件目标阶段：按js添加顺序执行事件冒泡阶段：子 –&gt; 父https://segmentfault.com/q/1010000004542336123456789101112131415161718192021222324252627282930var div1 = document.getElementById("div1");var div2 = document.getElementById("div2");var btn = document.getElementById("btn1");div1.addEventListener("click",function ( event ) &#123; console.log("div1,false");&#125;,false)div2.addEventListener("click",function ( event ) &#123; console.log("div2,false");&#125;,false)btn.addEventListener("click",function ( event ) &#123; console.log("btn,false");&#125;,false)div1.addEventListener("click",function ( event ) &#123; console.log("div1,true");&#125;,true)div2.addEventListener("click",function ( event ) &#123; console.log("div2,true");&#125;,true)btn.addEventListener("click",function ( event ) &#123; console.log("btn,true");&#125;,true)// 结果// div1,true// div2,true// btn,false 这里// btn,true// div2,false// div1,falseES6+进阶1(技能方向)git基础命令git add, git commit, git branch, git checkout, git checkout -b, git pull, git push, git clonegit flowsmaster, env-release, env-test, env-dev, feat-xx, hot-fixfeat: feat -&gt; dev -&gt; test -&gt; masterhotfix: hotfix -&gt; dev, hotfix -&gt; test, hotfix -&gt; master变基(rebase)与合并变基都要在 push 前交互式变基：优化log提交记录。合并、修改log、调整顺序普通变基：把A合并到B，代码上等效于，把B变基到A代码层面相同，log不一样遴选(cherry-pick)把某一条提交记录，合并到分支A贮藏(stash)把当前修改临时存储起来，需要的时候应用修改文件直接贮藏，新增文件要 git add 后在贮藏patch打补丁，类似遴选vue 2 全家桶(重点)原理遍历 data 对象，通过 Object.defineProperty 添加 getter 和 setter 方法。并 发布订阅和通知getter: 添加订阅 addSubsetter: 触发通知 notify实例化订阅 Watcher，实例化时触发 getter 订阅。修改触发 setter 时，通知 DOM 修改模板123456789101112131415161718192021222324252627282930313233// getter 与 setterfunction observe (data) &#123; if (!data || typeof data !== 'object') &#123; return &#125; Object.keys(data).forEach(key =&gt; &#123; defineReactive(data, key, data[key]) &#125;)&#125;function defineReactive (obj, key, value) &#123; // 递归子属性 observe(value) let dp = new Dep() Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; console.log('get: ', value) // 添加订阅: Dep.target的this指向的是dp实例 if (Dep.target) &#123; dp.addSub(Dep.target) &#125; return value &#125;, set: function reactiveSetter (newValue) &#123; console.log('set: ', newValue) value = newValue // 执行通知 dp.notify() &#125; &#125;)&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243class Dep &#123; constructor () &#123; this.subs = [] &#125; addSub (sub) &#123; this.subs.push(sub) &#125; notify () &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125;Dep.target = null // 全局属性function updateDiv (value) &#123; document.getElementById('div').innerText = value&#125;class Watcher &#123; constructor (obj, key, cb) &#123; // 手动触发getter，添加「订阅」 Dep.target = this this.obj = obj this.key = key this.value = obj[key] this.cb = cb Dep.target = null &#125; update () &#123; // 获取新值 this.value = this.obj[this.key] // 更新DOM this.cb(this.value) &#125;&#125;// ---------------------------- 调 用 ----------------------------let data = &#123; name: 'yy' &#125;observe(data)// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作; 手动触发「订阅」new Watcher(data, 'name', updateDiv)// 更新DOMdata.name = 'zz'new Vue 过程123456789101112Vue.prototype._init = function(options) &#123; // mergeOptions 实例化属性合并，包含extends/mixins属性 initLifecycle(vm) // 初始化组件生命周期标志符 initEvents(vm) // 初始化组件事件系统 initRender(vm) // 初始化组件render相关属性方法($createElement, $attrs, $listeners) callHook(vm, 'beforeCreate') // 拿不到 props data, 调用beforeCreate initInjections(vm) // 初始化组件依赖注入内容 initState(vm) // 初始化state(data, props, methods, watch, computed) initProvide(vm) callHook(vm, 'created') //调用created // 挂载template模板&#125;Vue 虚拟DOM操作 DOM 耗费性能太大，改用虚拟 DOMjs 创建虚拟 dom对象判断差异 diff 算法树的递归，广度优先判断列表差异判断属性的更改遍历子元素打标识渲染差异vue 基础生命周期beforeCreate: vue 实例的挂载元素 $el 和数据对象 data 都是 undefined，还未初始化created: 完成了 data 的初始化，$el 还未初始化beforeMount: vue 实例的 $el 和 data 都初始化了，相关的 render 函数首次被调用。实例已完成以下配置：编译模板，把 data 里的数据和模板生成 html。 注意此时 html 还没有挂载到页面上mounted: 在 el 被新创建出来的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下配置：用编译好的 html 内容替换 el 属性指向的 DOM对象。完成模板中的 html 渲染到 html 页面中，此过程中进行 ajax 交互beforeUpdate: 在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前调用。可以在该钩子中进一步地更改状态，不会触发附加的渲染状态updated: 在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以依赖与 DOM 的操作。然而在大多数情况下应避免在此期间更改状态，因为这可能会导致无限循环，该钩子在服务器端渲染期间不可用activated: keep-alive 激活时触发deactivated: keep-alive 缓存时触发beforeDestroy: 在实例销毁之前，实例仍完全可用destroyed: 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子函数在服务器端渲染期间被调用父子组件渲染顺序先父后子的原则多个子组件 单线程 渲染场景：父组件A，子组件B、C12345678910111213141516// 进入页面A.beforeCreateA.CreatedA.beforeMountB.beforeCreateB.CreatedB.beforeMountC.beforeCreateC.CreatedC.beforeMountB.MountedC.MountedA.Mounted12345678910// 离开页面A.beforeDestroyB.beforeDestroyB.destroyedC.beforeDestroyC.destroyedA.destroyed双向绑定响应化：Vue.observable(object)对象和数组要初始化单独响应化对象Vue.$set(object, key, value) or vm.$set(object, key, value) or this.$set(object, key, value)Object.assign({}, object, {a: 1, b:2})数组不能响应：用下标修改数组值和修改数组长度修改值：this.$set(array, index, value)array.splice(index, 1, value)修改长度：array.splice(newIndex)传值(6种)props、$emit中央事件总线 vue bus1234567891011121314151617181920// xxx.jslet eventBus = new Vue()export eventBus// 创建import eventBus from '../xxx.js'eventBus.$emit('name', params)// 监听mounted () &#123; eventBus.$on('name', fn)&#125;,beforeDestroy () &#123; eventBus.$off('name')&#125;,methods: &#123; fn (params) &#123; console.log('params', params) &#125;&#125;provide、inject多层父子组件，传变量(函数)，非响应式若要变为响应式，两种方法传递父组件实例过去，即传递 this12345678910provide () &#123; return &#123; xxx: this &#125;&#125;inject: ['xxx']inject: &#123; 'xxx': () =&gt; &#123;&#125;&#125;通过 Vue.observable() 传递响应式变量12345678provide () &#123; this.theme = Vue.observable(&#123; color: 'red' &#125;) return &#123; theme: this.theme &#125;&#125;vuex$parent、$children、$ref$parent: 父组件实例$children: 子组件实例，不保证顺序$ref:当前组件：DOM 元素子组件：子组件实例$attrs、$listeners$attrs: 子组件内使用，包含所有 父组件传递了但子组件 props 里未定义 的值，对象结构，值为 {key1: value1, key2: value2}$listeners: 子组件内使用，包含所有 父组件的非.native 方法。通过下面的操作，可以在多层父子组件传递1v-bind="$attrs"1v-on="$listeners"v-on事件修饰符https://cn.vuejs.org/v2/api/#vm-listeners.stop: 阻止冒泡 &lt;button @click.stop=&quot;xxx&quot;&gt;&lt;/button&gt;.prevent: 阻止默认行为.capture: 添加事件监听器时使用 capture 模式(捕获).self: 只当事件是从监听器绑定的元素本身触发时才触发回调.native: 监听组件根元素的原生事件prop单向数据流传递子组件的prop调用的父组件数据，当子组件修改时不想修改父组件方法一：prop作为 data 初始值，之后使用 data 的新值方法二：使用计算属性转换注意： 数组和对象是以引用的方式传递的，所以修改子组件的值时，也会修改父组件的值。这种情况下，需使用 深拷贝 生成新值，然后对新值修改。computed写法12345678910111213computed: &#123; aa () &#123; return this.xxx + &apos;11&apos; &#125;, bb () &#123; get: function () &#123; return this.bb + &apos;22&apos; &#125;, set: function (value) &#123; this.bb = value + &apos;xx&apos; &#125; &#125;&#125;watch写法aa () {}aa.bb () {}1234567watch: &#123; cc: &#123; handler: &apos;methods&apos;, deep: true, immediate: true &#125;&#125;computed，watch，methods区别watch：监听回调，当依赖的值有改变时，触发回调执行一些逻辑computed：计算属性，根据依赖的值动态显示最新的结果，会缓存(getter后)。能监听到obj深层keymethods：方法，执行函数methods和computed：methods每次渲染时都会计算，而computed会从缓存取值mixin混入文件写法和单页面文件一样调用混入以数组方式引入 mixins: [myMixin]合并规则data: 递归合并，同名时以 组件 优先钩子函数：都会调用，混入文件 优先调用其他对象(methods, components, directives): 合并为一个对象，同名时以 组件 为准全局混入12345678Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)keep-alive缓存未激活的组件123&lt;keep-alive&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;include: 字符串或正则，匹配的才会缓存exclude: 字符串或正则，匹配的都不会缓存max: 数字，最多缓存多少实例slot定义插槽： &lt;slot name=&quot;xxx&quot;&gt;&lt;/slot&gt;使用插槽：&lt;template v-slot:&quot;xxx&quot;&gt;&lt;/template&gt;, v-slot 可以缩写为 #当插槽所在的父作用域 要 使用子作用域时，可以把子作用域作为变量传递给父1234567&lt;!-- 子 --&gt;&lt;span&gt; &lt;slot v-bind:user="user"&gt; &#123;&#123;user.firstName&#125;&#125; &lt;/slot&gt; &lt;slot name="other" v-bind:dou="dou" v-bind:ruai="ruai" v-bind:mi="mi"&gt;&lt;/slot&gt;&lt;/span&gt;12345&lt;!-- 父 --&gt;&lt;current-user&gt; &lt;template v-slot:default="&#123; user &#125;"&gt;&lt;/template&gt; &lt;template v-slot:other="&#123; dou, ruai, mi &#125;"&gt;&lt;/template&gt;&lt;/current-user&gt;v-slot:aa、#aa : 使用插槽v-slot:bb={}: 使用插槽传值v-slot={}: 使用插槽传值，默认名，等效于 v-slot:default={}过度、动画效果触发时机v-if、v-show、动态组件、组件根节点单组件触发&lt;transition name=&quot;t&quot;&gt;&lt;/transition&gt;使用 t-xx 定义状态样式，如未定义 name， 默认为 v-xxx-enter、x-enter-active、x-enter-to、x-leave、x-leave-active、x-leave-to，一般使用 x-enter、x-enter-active、x-leave-active、x-leave-to 4个状态x-enter-active、x-leave-active: 激活时状态(稳定)多组件 li 触发&lt;transition-group name=&quot;x&quot;&gt;&lt;/transition-group&gt;样式定义同上x-move：位置移动时平滑移动 transition: transform 1s常用API指令Vue.directive(&#39;name&#39;, { ... })，&lt;button v-name=&quot;xxx&quot;&gt;&lt;/button&gt;，官网钩子函数：bind: 只调用一次，第一次绑定到元素时调用。inserted: 被绑定元素插入到父节点时调用。update: 组件所在 VNode 更新时调用。componentUpdated: 组件所在 VNode 及其子 VNode 全部更新后调用。unbind: 只调用一次，解绑时调用。钩子函数参数：所有钩子参数一样，除了 el 其他参数都只读el: 绑定元素DOM，可直接操作binding: 一个对象，包含下面值name: 指令名，不包含 v- 前缀value: 指令的绑定值。v-dire=&quot;1 + 1&quot; 中，绑定值为 2oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用expression: 字符串形式的表达式。v-dire=&quot;1 + 1&quot; 中，表达式为 1 + 1arg: 传给指令的参数，可选。v-dire:foo 中，参数为 foomodifiers: 一个包含修饰符的对象。v-dire.foo.bar 中，修饰符对象为 { foo: true, bar: true }vnode: 虚拟节点oldVnode: 上一个虚拟节点实例 v-longpress1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// directive.jsimport Vue from 'vue'Vue.directive('longpress'', &#123; bind: function (el, binding, vNode) &#123; // 确保提供的表达式是函数 if (typeof binding.value !== 'function') &#123; // 获取组件名称 const compName = vNode.context.name // 将警告传递给控制台 let warn = `[longpress:] provided expression '$&#123;binding.expression&#125;' is not a function, but has to be ` if (compName) &#123; warn += `Found in component '$&#123;compName&#125;' ` &#125; console.warn(warn) &#125; // 定义变量 let pressTimer = null // 定义函数处理程序 // 创建计时器（ 2秒后执行函数 ） // 不是鼠标左键返回 let start = (e) =&gt; &#123; if (e.type === 'click' &amp;&amp; e.button !== 0) &#123; return &#125; if (pressTimer === null) &#123; pressTimer = setTimeout(() =&gt; &#123; // 执行函数 handler() &#125;, 2000) &#125; &#125; // 取消计时器 let cancel = () =&gt; &#123; // 检查计时器是否有值 if (pressTimer !== null) &#123; clearTimeout(pressTimer) pressTimer = null &#125; &#125; // 运行函数 const handler = (e) =&gt; &#123; // 执行传递给指令的方法 binding.value(e) &#125; // 添加事件监听器 el.addEventListener('mousedown', start) el.addEventListener('touchstart', start) // 取消计时器 el.addEventListener('click', cancel) el.addEventListener('mouseout', cancel) el.addEventListener('touchend', cancel) el.addEventListener('touchcancel', cancel) &#125; &#125;)vue clivue loadervue router12345678910111213141516171819202122232425262728293031// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1. 定义 (路由) 组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由// 每个路由应该映射一个组件。 其中"component" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // (缩写) 相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app')// 现在，应用已经启动了！hash、history模式默认 hash 模式，即 url 上带 # 的模式。hashchange 事件history模式: url 像正常url一样，需要后端支持。popstate、pushstate 事件router、routerouter: 路由实例router.beforeEach、router.beforeResolve、router.afterEach、router.push、router.replace、router.go、router.back、router.forward等this.$route: 当前路由对象，当前激活的路由对象信息path:params:query:hash:fullPath:matched: 一个数组，包含当前路由的所有嵌套路径片段的路由记录name:redirectedFrom: 如果存在重定向，即为重定向来源的路由的名字传值params:不能和 path 一起使用，一起使用时 params 会失效传递：this.$router.push({name: &#39;xxx&#39;, params: {...}})获取：let a = this.$route.paramsquery:任何场合传递：this.$router.push({path: &#39;/setup&#39;, query: {}})导航守卫组件内的守卫beforeRouteLeavebeforeRouteUpdatebeforeRouteEnter全局导航守卫beforeEachafterEach全局解析守卫beforeResolve：在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。路由独享的守卫beforeEnter路由导航顺序导航被触发在失活的组件里调用 beforeRouteLeave 守卫调用全局的 beforeEach 守卫在重用的组件内调用 beforeRouteUpdate 守卫在路由配置里调用 beforeEnter 守卫解析异步路由组件在被激活的组件里调用 beforeRouteEnter 守卫调用全局的 beforeResolve 守卫导航被确认调用全局的 afterEach 钩子触发 DOM 更新调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的实例会作为回调函数的参数传入vuex专门为 vue 设计的 状态管理模式State状态：store.state.xxx 或 this.$store.state.xxxstore.state.moduleName.xxx 或 this.$store.state.moduleName.xxx12345678910import &#123; mapState &#125; from 'vuex'computed: &#123; ...mapState(&#123; count1: state =&gt; state.count1, countAlias: 'count' &#125;), // 或者 ...mapState(['count', 'count1'])&#125;Gettersstate 的计算属性，但如果有变量传入时，则每次都会计算(不会缓存)this.$store.getters.xxx 或 this.$store.getters.modulesName.xxx通过属性访问12345getters: &#123; doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125;通过方法访问123456// 每次访问都会调用，而不会缓存结果getters: &#123; getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125;&#125;通过辅助函数 mapGetters 访问123456789101112import &#123; mapGetters &#125; from 'vuex'computed: &#123; ...mapGetters([ 'doneTodosCount', 'otherGetters' ]), // 或者 ...mapGetters(&#123; aliasName: 'doneTodosCount' &#125;)&#125;Mutations修改 state 的唯一方式只能是同步逻辑只能是修改 state建议 大写、常量 命名定义12345mutations: &#123; UPDATE_USER (state, payload) &#123; state.age += payload.age &#125;&#125;调用123456this.$store.commit('name', payload)// or this.$store.commit(&#123; type: name, ...payload&#125;)123456789101112import &#123; mapMutations &#125; from 'vuex'methods: &#123; ...mapMutations([ 'mA', 'mB' ]), // 或者，可以重命名 ...mapMutations(&#123; aliasName: 'mA' &#125;)&#125;Actions异步，返回 promise可以写复杂逻辑，一般用于调用 mutations用法，参数基本和 mutations 一致定义123456actions: &#123; increment (&#123; state, getters, commit, dispatch &#125;, payload) &#123; // 可以写复杂逻辑 commit('INCREMENT', payload) &#125;&#125;调用123456this.$store.dispatch('increment', payload)// 或者this.$store.dispatch(&#123; type: 'increment', ...payload&#125;)123456789101112import &#123; mapActions &#125; from 'vuex'methods: &#123; ...mapActions([ 'aA', 'aB' ]), // 或者 ...mapActions(&#123; aliasName: 'aA' &#125;)&#125;namespace、module按模块区分，添加 namespaced: true 即可调用需加上 moduleNamethis.$store.state.moduleName.xx、this.$store.getters.moduleName.xx、this.$store.commit(&#39;moduleName/xxx&#39;)、this.$store.dispatch(&#39;moduleName/xxx&#39;)12345678910111213141516171819computed: &#123; ...mapState('moduleName', ['xxx', 'yyy']), ...mapGetters('moduleName', ['xxx', 'yyy'])&#125;,methods: &#123; ...mapMutations('moduleName', ['xxx', 'yyy']), ...mapActions('moduleName', ['xxx', 'yyy'])&#125;// 或者使用 createNamespacedHelpers 创建基于命名空间的辅助函数const &#123; mapState, mapActions &#125; = createNamespacedHelpers('some/nested/module')computed: &#123; ...mapState(['xxx', 'yyy']), ...mapGetters(['xxx', 'yyy'])&#125;,methods: &#123; ...mapMutations(['xxx', 'yyy']), ...mapActions(['xxx', 'yyy'])&#125;在带命名空间的模块内调用全局内容state 和 getters: rootState 和 rootGetters 作为第三、第四个参数传给 getters，也会作为 context 传给 actionmutations 和 actions: 若要在全局命名空间内分发 action 或 提交 mutation， 将 { root: true } 作为第三个参数传递给 dispatch 或 commit 即可12345678910111213141516171819202122232425262728293031modules: &#123; foo: &#123; namespaced: true, getters: &#123; // 在这个模块的 getter 中，`getters` 被局部化了 // 你可以使用 getter 的第四个参数来调用 `rootGetters` someGetter (state, getters, rootState, rootGetters) &#123; getters.someOtherGetter // -&gt; 'foo/someOtherGetter' rootGetters.someOtherGetter // -&gt; 'someOtherGetter' &#125;, someOtherGetter: state =&gt; &#123; ... &#125; &#125;, actions: &#123; // 在这个模块中， dispatch 和 commit 也被局部化了 // 他们可以接受 `root` 属性以访问根 dispatch 或 commit someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123; getters.someGetter // -&gt; 'foo/someGetter' rootGetters.someGetter // -&gt; 'someGetter' dispatch('someOtherAction') // -&gt; 'foo/someOtherAction' dispatch('someOtherAction', null, &#123; root: true &#125;) // -&gt; 'someOtherAction' commit('someMutation') // -&gt; 'foo/someMutation' commit('someMutation', null, &#123; root: true &#125;) // -&gt; 'someMutation' &#125;, someOtherAction (ctx, payload) &#123; ... &#125; &#125; &#125;&#125;modules 定义全局 action: 添加 root: true， 并将这个 action 的定义放在函数 handler 中12345678910111213141516171819&#123; actions: &#123; someOtherAction (&#123;dispatch&#125;) &#123; dispatch('someAction') &#125; &#125;, modules: &#123; foo: &#123; namespaced: true, actions: &#123; someAction: &#123; root: true, handler (namespacedContext, payload) &#123; ... &#125; // -&gt; 'someAction' &#125; &#125; &#125; &#125;&#125;动态导入 modules1234567891011121314151617// https://webpack.js.org/guides/dependency-management/#requirecontextconst modulesFiles = require.context('./modules', true, /\.js$/)// you do not need `import app from './modules/app'`// it will auto require all vuex module from modules fileconst modules = modulesFiles.keys().reduce((modules, modulePath) =&gt; &#123; // set './app.js' =&gt; 'app' const moduleName = modulePath.replace(/^\.\/(.*)\.\w+$/, '$1') const value = modulesFiles(modulePath) modules[moduleName] = value.default return modules&#125;, &#123;&#125;)export default new Vuex.Store(&#123; modules, getters&#125;)动态导入组件123456789101112131415161718192021// global.js文件import Vue from 'vue'function changeStr (str) &#123; return str.charAt(0).toUpperCase() + str.slice(1)&#125;const requireComponent = require.context('./', false, /\.vue$/)// 查找同级目录下以vue结尾的组件const install = () =&gt; &#123; requireComponent.keys().forEach(fileName =&gt; &#123; let config = requireComponent(fileName) console.log(config) // ./child1.vue 然后用正则拿到child1 let componentName = changeStr( //fileName.replace(/^\.\//, '').replace(/\.\w+$/, '') fileName.replace(/^\.\/(.*)\.vue$/, '$1') ) Vue.component(componentName, config.default || config) &#125;)&#125;export default &#123; install // 对外暴露install方法&#125;ssrui框架ui框架类似，以 iview 举例iview / iview Design安装全局引入: vue.use(iview) css按需引入: css + babelrc, babel-plugin-import国际化i18n全局配置Vue.use(ViewUI, {xxx})validatorprop和key一致required: true, message: &#39;xx&#39;, trigger: &#39;blur&#39;type: &#39;string&#39;, pattern: &#39;/^(0|[1-9][0-9]*)$/&#39;, message: &#39;xx&#39;, trigger: &#39;change&#39;validator: this.xxx&#39;, trigger: &#39;blur&#39;1234567const validateQualityValueMile = (rule, value, callback) =&gt; &#123; if (this.isGasControl &amp;&amp; !value &amp;&amp; !this.carForm.qualityValueDay) &#123; console.log('vMile ', value) return callback(new Error('质量保证期必须填写')) &#125; return callback()&#125;vantelement-uiant-designiconfont添加图标，命名下载后，添加6个文件(除了demo的css，js)，引入iconfont.css&lt;span class=&quot;iconfont xxx&quot;&gt;vue 3(重点)option APIcomposition API区别(响应速度、原理等)区别(vue 2)语法？ts基础基本类型：string, number, boolean, null, undefined, Symbol, BigInt| : 联合类型，同时只能是多个类型中其中一个&amp;: 交叉类型，同时是所有类型的所有进阶type: 类型别名，= 赋值interface: 接口，直接赋值type 与 interface 的区别：基本一致。赋值方式不一样；接口可以合并，类型别名需用 &amp; 生成 交叉类型class：类constructor : 构造函数extends : 继承(类-类，类-接口，接口-接口，接口-类)super: 调用父类的构造函数修饰符public: 公开，默认private: 私有的，只能当前类使用protected: 和 private 类似，区别是子类也可以使用implements: 类实现接口在 TS 里，接口是可以继承类的abstract: 抽象类，抽象方法抽象类不能被实例化抽象方法必须在子类实现自带函数typeof: 获取实例的类型, type x = typeof xxInstancekeyof: 获取 type 或 interface 的 key 的联合类型partial: 所有key变为可选required: 所有key变为必填readonly: 所有key变为只读record: 所有key变为指定T类型pick: 选择部分keyextract: 遍历T.keys，返回U中存在的keys的类型，参数和结果都是联合类型exclude: 遍历T.keys， 返回U中 不存在的keys类型，参数和结果都是联合类型omit: pick+exclude组合，返回 对象中，除几个key外的其他所有类型。和pick对应webpack进阶2(管理方向)脚手架搭建中后台脚手架实践基础封装axioses lintgit-hookprettierjenkins进阶3(面试题)原型链与继承js -&gt; 原型/原型链输入url之后跳转异步：宏任务与微任务https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7顺序：同步 -&gt; 宏任务队列1 -&gt; 微任务队列1 -&gt; 宏任务队列2 -&gt; 微任务队列2宏任务：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)微任务：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)Tips:promise(A).then(B)内的A函数为立即执行，B函数为微任务队列B 里如果 return promise，会添加到微任务队列最后，如果 return xx(number | string)，则立即执行await A; B() 的A函数为立即执行，B函数为微任务队列微任务里创建的微任务(无论多少层)，都在当前微任务队列内执行(添加到当前微任务列表最后)123456789promise.resolve().then(() =&gt; &#123; console.log(1) promise.resolve().then(() =&gt; &#123; console.log(2) &#125;)&#125;).then(() =&gt; &#123; console.log(3)&#125;)// =&gt; 返回1,2,3script 执行完后，会直接执行 微任务，所以默认顺序为：同步 -&gt; 微任务1 -&gt; 宏任务2 -&gt; 微任务2 -&gt; …Promise原理注册 then 回调函数，push 到 callbacks里。当 resolve 时，调用 callbacks 里所有函数。PWA渐进式应用程序web worker: 单独开线程执行任务：12345678910111213141516// main.jsconst myWorker = new Worker('worker.js')// 传递myWorker.postMessage('hello')// 接收myWorker.onmessage = function(e) &#123; console.log(e.data)&#125;// worker.js, 回立即执行self.onmessage = function(e) &#123; console.log(e.data) // 向主文件发送信息 self.postMessage('lala')&#125;service worker: 可以拦截网络请求，决定走网络还是返回缓存数据，所以可以实现「后退」功能脚手架发布package.json.main: &quot;bin/mbs.js&quot;js取整简书parseInt~~20.2520.25^020.25 &lt;&lt; 0MathMath.floorMath.ceilMath.roundMath.trunc: 直接取整js动效js动效中：setTimeout、setInterval 并不是间隔 xx 开始渲染页面，而是间隔 xx 添加到 任务队列 中，如果队列里已经有任务的话…..requestAnimationFrame(callback): 在下一次重绘前，执行动效。重绘是浏览器决定1234567891011121314151617const element = document.getElementById('ele')const start = null// timestamp: 当前时间戳function step(timestamp) &#123; if (start === undefined) &#123; start = timestamp &#125; const elapsed = timestamp - start element.style.transform = 'translateX(' + Math.min(0.1 * elapsed, 200) + 'px )' // 2s 后停止动画 if (elapsed &lt; 2000) &#123; window.requestAnimationFrame(step) &#125;&#125;window.requestAnimationFrame(step)实际面试this.$nextTick 原理创建异步延迟函数 timerFunc，在异步延迟结束后，调用传入的回调函数timerFunc，延迟调用优先级：Promise.resolve().then() &gt; MutationObserver &gt; Setimmediate &gt; setTimeout：2微任务，2宏任务nextTick(cb?, ctx)，如果未传入 cb，会自动返回 Promise.resolve()，可用 then 调用后续函数。vuex缺点内存占用大vue 渲染原理虚拟DOM啥的vue 多页面是什么多个html页面，除了主页内是vue-router跳转，其他页面都是a标签跳转到其他页面主页面加载快，多页面SEO好多页面之间跳转慢，因为要加载css和jsjs为啥会阻塞页面渲染js可能会修改DOM结构，比如 document.write事件委托/事件代理利用事件冒泡，只为父元素添加事件，进而达到为多个子元素添加事件的效果减少DOM查询，提升性能，可扩展，新增的子元素也可直接代理不冒泡的事件不支持；冒泡过多可能被阻止掉；别人使用时误判导致调用2次掘金事件循环执行栈：主线程，同步事件队列：异步，主线程 -&gt; 事件队列 -&gt; 主线程 -&gt; 事件队列 -&gt; …知乎 githubWeb 性能优化网络、资源同域名下减少DNS解析开启http2，多路复用压缩图片，懒加载(layzsizes)，雪碧图，iconfont图标gzip压缩代码静态包，包含下载好的首页等css修改类名而不是样式减少DOM访问：事件代理减少重排重绘：不使用table开启硬件加速：animations、transforms、transitions不会自动开启，当检测到DOM元素开启某些规则时会开启，比如3D变化transform: translate3d(250px, 250px, 250px) rotate3d(250px, 250px, 250px, -120deg) scale3d(0.5, 0.5, 0.5) (左手，右下前)有时候不想3d的转换，可以使用小技巧欺骗 transform: translateZ(0)但此时会屏幕闪烁，可以这样解决 backface-visibility: hidden; perspective: 1000 或者 transform: translate3d(0, 0, 0) 参考资料元素背面朝向观察者时是否可见；观察者距离z=0平面的距离。js减少js体积，webpack chunk打包web worker 开线程优化代码，减少循环函数节流commonJs, ES6 modulecommonJs: 动态编译，使用时才编译；可使用变量；值拷贝，不影响es6 module: 静态编译，先一次性编译好，后面使用；所以编译的时候就能够分析代码是否被使用，进而使用 tree shaking；值应用，共享数据浏览器缓存浏览器缓存https建立过程TLS建立过程]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>面试</tag>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家庭网络的升级之旅(二)]]></title>
    <url>%2F2021%2F01%2F19%2Fhome-net-2%2F</url>
    <content type="text"><![CDATA[你问我(一)在哪里？其实并没有写，因为我懒。。。。。(小声bb)那么(一)是什么呢，简单来说就是加了个软路由 r2s，用 主路由 的模式实现了路由翻墙～升级之旅(一)痛点每个设备出国留学都要开相应的软件：Windows -&gt; v2rayN，Mac -&gt; v2rayU，ios -&gt; shadowRocketPC上代理游戏流量还得单独开 proxifier 软件，参考之前写的一片文章 ss + proxifier 实现vpn游戏代理switch 联网得通过共享 wifi 的方式，一直开着 PC 或者 iphone种种的不便大大降低了用户体验，尤其是玩 switch 的时候，每次都要特意开 PC 或 iphone 挂着，实在是不方便了～那么，有什么方法能一起解决上面的问题呢？解决方案答案，当然是有的，路由翻墙就是很好的一种方案！路由器翻墙后，连接路由器的所有设备(有线/无线)都会根据流量规则自行决定是否翻墙在 路由翻墙插件 里，设置 协议规则：TCP: 使用 v2ray 协议，上网速度快；UDP: 使用 ss 协议，玩游戏稳定(上网速度慢)Tips：之所以 UDP 使用 ss 而不使用 v2ray，因为 v2ray 不适合作为游戏的流量协议，v2ray 进行了多次流量转换，网络类型很差，比如在 switch 里：UDP 使用 ss 时：NAT 类型为A，网络质量最好UDP 使用 v2ray 时：NAT 类型为D，网络质量非常差，基本不能联机Ok，理论方案已经确定，接下来就是实践开始～硬路由尝试最开始是直接尝试用硬路由刷 梅林固件、老毛子固件 等，但硬路由配置太低，刷了系统后跑不起来，最后决定直 接 上 软路由！！软路由软路由选择了入门级的 r2s ，因为性价比极高，只要200块就行，性能也够，而且体积非常小，很方便～然后就是常规操作了，刷固件，配置 passwall，选择代理模式：TCP: v2ray 协议，默认模式为 中国大陆以外UDP: ss 协议，默认模式为 游戏模式家庭网络采用 主路由 的连接方式：光猫 -&gt; 软路由 -&gt; 硬路由(作为路由器) -&gt; 多个设备ABCDE软路由 中使用 passwall 插件进行路由翻墙硬路由 中进行 IP 与 MAC 绑定，wifi 发射，多个设备ABCDE 的 连接限制、网络限制等功能到此为止，之前的需求都满足了，完美！升级之旅(二)之后的时间一直都运行完美，直到入手了 喷喷(喷射战士2)….新的痛点之前有说过，网页都走 TCP 的 v2ray 协议，网速快，游戏都走 UDP 的 ss 协议，网络稳定。但是，喷喷 是个特例….. 这游戏会同时走 TCP 和 UDP 协议，而且对网络要求极高，NAT 必须是 B 以上。换句话说就是，玩 喷喷 的时候，TCP 也要设置成 ss 协议。。。。那么，新问题来了，玩 喷喷 的时候设置成 ss 协议，玩完后改回 v2ray 协议？不行～～ 这样太麻烦了…..所以…有方法能解决上面的问题吗？🤔️方案经过大量的查阅资料，发现了一种可行的方案：passwall 里设置2个 TCP 协议，分别是 TCP1 -&gt; v2ray 和 TCP2 -&gt; ss默认设置为 TCP1重点： 在 访问控制 里，通过 IP 或 MAC 匹配到 switch，然后设置为 TCP2按理来说这样应该就可行了。但是，新的问题又出现了，当前 主路由 模式下，软路由 只能获取 硬路由 的 IP 和 MAC， 而 设备ABCDE 的 IP 和 MAC 又只能在 硬路由 中获取，而且 软路由r2s 只有一个 LAN 口，不能同时接多个 设备ABCDE。也就是说，r2s 不能识别到 switch，进而不能用 访问控制 来设置为 TCP2 了…然后我又想到了交换机的 中继AP 模式，正好完美解决当前的问题了…..其实就是把之前 主路由 模式下的 硬路由，从 路由器 改为 交换机 的功能，这样 硬路由 就相当于一个 hub 类似的功能，不提供实际 IP 和 MAC，只提供分流功能，把 软路由 LAN 出来的流量直接给对应的 设备ABCDE，而且这种情况下，软路由 可以直接获取到 设备ABCDE 的 IP 和 MAC，进而就能通过 访问控制 设置 switch 的 TCP 了新的家庭网络连接方式passwall相关配置这样配置后，上面的问题就完美解决啦～剩余问题理论上讲，上面的方案配置正确的话，应该是可行的。但实际发现，访问控制 这个功能并没有生效。网上查找资料后发现，貌似是新版本 passwall 有这个问题，旧版本就没有….然后吧…给作者提了个 issue ，等待大佬的修复…..2021.01.24 更新作者回复了，备注里不能有空格….然后试了下，果然就可以了……之前还升级 固件、passwall 版本折腾了好久。。。。另外再吐槽下，switch 的 wifi 性能真是辣鸡!!，时不时的来一次掉线…..最后还是买了 usb网络交换器 有线连 switch …PS：注意同时兼容 有线模式 和 无线模式 ～～最终成果经过这次升级后，家里的网络更加智能啦～可以根据规则指定 某些设备 走 指定的协议，而不会对主网络(默认 v2ray 的 TCP 协议)有影响。比如 switch ， 可以指定全程走 ss 协议，然后就可以愉快的 喷喷 啦～ 😊]]></content>
      <categories>
        <category>一起哈啤</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
        <tag>vpn</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中后台系统之mbs-cli脚手架集成]]></title>
    <url>%2F2021%2F01%2F06%2Fmy-cli%2F</url>
    <content type="text"><![CDATA[一般，我们知道为什么需要脚手架？减少重复性的工作，不再需要复制其他项目再删除无关代码，或者从零创建一个项目和文件。根据交互动态生成项目结构和配置文件，具备更高的灵活性和人性化定制的能力。多人协作更为方便，避免了人工传递文件的繁琐。集成互联网上的模板，方便自己与他人使用。脚手架工作流脚手架问答流如何搭建一个脚手架第三方库的支持搭建步骤1、初始化项目首先创建一个空项目，命名为 mbs-cli ，然后新建一个 bin/mbs 文件，再执行 npm init 生成一个 package.json 文件。最后安装上面需要用到的依赖。123mkdir mbs-cli &amp;&amp; cd mbs-climkdir bin &amp;&amp; cd bin &amp;&amp; touch mbs &amp;&amp; cd ../ &amp;&amp; npm initnpm install commander download-git-repo inquirer handlebars ora chalk log-symbols cli-table -S2、处理命令行node.js 内置了对命令行操作的支持，在 package.json 中的 bin 字段可以定义命令名和关联的执行文件。在 package.json 中加上 bin 的内容：12345678&#123; "name": "mbs-cli", "version": "1.0.0", "description": "中后台系统脚手架", "bin": &#123; "mbs": "bin/mbs" &#125;&#125;首先在 mbs 文件中引入相关依赖模块：123456789#!/usr/bin/env nodeconst &#123; existsSync &#125; = require('fs') // 系统内置模块 主要用来操作文件const program = require('commander') // 自动的解析命令和参数，用于处理用户输入的命令const chalk = require('chalk') // 给终端的字体加上颜色const symbols = require('log-symbols') // 在终端上显示出 ✔︎ 或者 ✘ 等的图标const &#123; resolve &#125; = require('path')const res = command =&gt; resolve(__dirname, '../commands/', command)然后编写nodejs处理逻辑，具体用法见下。nodejs依赖模块介绍与用法commander（指挥官）自动地解析命令和参数，用于处理用户输入的命令usage(): 设置usage值，自定义帮助信息command(): 定义一个命令名字description(): 设置 description值option(): 定义参数，需要设置「关键字」和 「描述」，关键字包括「简写」和「全写」两部分，以 ,、|、空格 做分隔parse(): 解析命令行参数 argvversion(): 终端输出版本号定义常规命令：123// 定义常规命令program.usage('&lt;command&gt;')program.version(require('../package').version)init命令逻辑1234567891011121314// init 命令逻辑program .command('init &lt;name&gt;') .description('Generate a new project') .alias('i') .action((name) =&gt; &#123; if (!existsSync(name)) &#123; console.log(name) require(res('init')) &#125; else &#123; // 错误提示项目已存在，避免覆盖原有项目 console.log(symbols.error, chalk.red('Project already exists')) &#125; &#125;)处理用户输入命令1234567891011121314// init 命令逻辑program .command('init &lt;name&gt;') .description('Generate a new project') .alias('i') .action((name) =&gt; &#123; if (!existsSync(name)) &#123; console.log(name) require(res('init')) &#125; else &#123; // 错误提示项目已存在，避免覆盖原有项目 console.log(symbols.error, chalk.red('Project already exists')) &#125; &#125;)最后处理解析命令行参数12345678program.parse(process.argv)// program.parse: 解析命令之中的参数，根据上面定义好的规则执行命令// process: 一个全局对象，控制有关信息，控制node.js的进程// process.argv: 该属性返回一个数组，这个数组包含了启动node.js进程时的命令行参数if (!program.args.length) &#123; program.help()&#125;inquirer（询问者）通用的命令行用户界面集合，用于和用户进行交互。由于交互的问题种类不同，inquirer 为每个问题提供很多参数12345678910type: 表示提问的类型，包括：input, confirm, list, rawlist, expand, checkbox, password, editor;name: 存储当前问题回答的变量;message: 问题的描述；default: 默认值;choices: 列表选项，在某些type下可用，并且包含一个分隔符(separator)；validate: 对用户的回答进行校验‘filter: 对用户的回答进行过滤处理，返回处理后的值;when: 根据前面问题的回答，判断当前问题是否需要被回答；prefix: 修改message默认前缀；suffix: 修改message默认后缀；语法结构123456789const inquirer = require('inquirer')const promptList = [ // 具体交互内容]inquirer.prompt(promptList).then(answers =&gt; &#123; console.log(answers) // 返回的结果&#125;)input类型1234567const promptList1 = [ &#123; type: 'input', name: 'author', message: '请输入作者名称' &#125;]效果confirm类型1234567891011121314151617const promptList2 = [ &#123; type: 'confirm', name: 'watch', message: '是否使用监听？', prefix: '前缀' &#125;, &#123; type: 'confirm', name: 'filter', message: '是否使用过滤？', when: function (answers) &#123; // 当watch为ture时才会提示当前问题 return answers.watch &#125;, suffix: '后缀' &#125;]效果list类型123456789101112131415const promptList3 = [ &#123; type: 'list', message: '请选择一种水果：', name: 'fruit', choices: [ 'Apple', 'Pear', 'Banana' ], filter: function (val) &#123; // 使用 filter 将回答变为小写 return val.toLowerCase() &#125; &#125;]效果download-git-repodownload-git-repo 支持从 Github 、Gitlab、Bitbucket 下载仓库1download(repository, destination, options, callback)repository1234- GitHub - github:owner/name or simply owner/name- GitLab - gitlab:owner/name- Bitbucket - bithucket:owner/name- Direct - direct:url:branchdestination1The file path to download the repository to. xxxxxxxxxoptions123boolean default false - if true use git clone instead of an http download. while this can be a bit slower, it does allow private repositories to be used if the appropriate SSH keys are setup.callback1The callback function as function (err).ora（loading动效）用于显示下载中的动画效果123456789const ora = require('ora')const spinner = ora('正在下载模板...')// 开始下载spinner.start()// 下载成功spinner.succeed('模板下载成功！')// 下载失败spinner.faild('模板下载失败！')chalk（字体颜色）通过 chalk 来为打印信息加上样式，比如成功信息为绿色，失败信息为红色。这样子会让用户更加容易辨认，同时也让终端的显示更加好看：123const chalk = require('chalk')console.log(chalk.green('项目创建成功'))console.log(chalk.red('项目创建失败'))log-symbols（日志符号）使用 log-symbols 在信息前面加上 ✔︎ 或者 ✘ 等的图标，优化视觉体验：1console.log(symbols.success, chalk.green('New project has been initialize successfully!'))handlebarshandlebars 可以对仓库的模板中的 package.json 文件做一些动态修改：123456789101112131415&#123; "name": "&#123;&#123;name&#125;&#125;", "version": "1.0.0", "description": "&#123;&#123;description&#125;&#125;", "bin": &#123; "mbs": "bin/mbs" &#125;, "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "&#123;&#123;author&#125;&#125;", "license": "ISC", ...&#125;并在下载模板完成之后将用户输入的答案渲染到 package.json 中123456789101112131415161718192021const &#123; readFileSync, writeFileSync &#125; = require('fs')const handlebars = require('handlebars')function reWrite (name, answers) &#123; const filename = './package.json' const meta = &#123; name, description: answers.description, author: answers.author &#125; const content = readFileSync(filename).toString() const result = handlebars.compile(content)(meta) writeFileSync(filename, result) // 或者添加其他依赖包 const content = readFileSync(filename, 'utf-8') const obj = JSON.parse(content) obj.dependencies['echart'] = '^0.1.3' const result = handlebars.compile(JSON.stringify(obj, null, 2))(meta) writeFileSync(filename, result)&#125;cli-table表格12345678910111213141516const Table = require('cli-table')const template = require(`$&#123;__dirname&#125;/../templates.json`)const table = new Table(&#123; head: ['Template Name', 'Branch', 'Url '], style: &#123; head: ['green'] &#125;&#125;)// 添加数据table.push(['template1', 'branch1', 'url1'])// 显示数据console.log(table.toString())shelljs执行命令行命令 cd path &amp;&amp; npm i123456789101112131415var shell = require('shelljs')shell.cd(meta.name)shell.exec('npm i', function (err, stdout, stderr) &#123; if (err) &#123; spinner.fail() console.log(symbols.error, chalk.red(err)) &#125; else &#123; spinner.succeed() console.log( symbols.success, chalk.green('The object has installed dependence successfully!') ) &#125;&#125;)msb-cli脚手架mbs-cli工作流mbs-cli目录结构mbs-cli核心命令本地npm模块调试开启调试模式npm link 可以将当前目录 ./bin 文件夹下的 npm包 链接到全局执行环境，从而在任意位置使用命令行都可以直接运行该 npm包关闭调试模式在当前目录下执行 npm unlink 即可删除链接符号]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>nodejs</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动效小结]]></title>
    <url>%2F2020%2F11%2F16%2Fanimation%2F</url>
    <content type="text"><![CDATA[接上一篇文章，最近ui优化做的比较多，动效优化也是其中一部分。动效的几种使用方式也都尝试过了，所以吧，做个小结记录一下～使用方式手写动效css 写法vue 写法第三方动效库animejslottie手写动效手写动效，使用 css 来描述样式，适用于较简单的动效css 写法制定父元素的 transition 属性后，子元素的 show 和 hide 都会有动效，如果只在子元素里写 transition (比如hover)，则只在 show 的时候有动效transition ：要显示的动效类型，时间，持续显示方式 – all/transform/等，1000ms/s，ease/ease-in-out/linear/等具体样式：包括 opacity、translate、scale、rotate 等。Demo相关代码1234&lt;div class="title" @click="clickIcon"&gt; &lt;div class="bg" :style="bgStyles"&gt;&lt;/div&gt; &lt;span class="sp"&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;&lt;/div&gt;12345678910111213141516171819202122.title &#123; text-align: center; font-weight: 500; .bg &#123; width: @bg-r; height: @bg-r; margin: 0 auto; cursor: pointer; border-radius: 100%; transition: all 0.5s ease; &amp;+.sp &#123; transition: all 0.3s ease-in-out; &#125; &amp;:hover &#123; box-shadow: 0 0 10px 0 rgba(0, 154, 255, 0.5); transform: scale(1.2); &amp;+.sp &#123; color: #009AFF; &#125; &#125; &#125;&#125;Vue 写法和传统的 css 写法不同，Vue 写法多了一个 transition 和 transition-group 的写法使用 name=&#39;x&#39; + x-YYYY 的写法来描述动效过程只有在组件切换的时候才会触发动效v-ifv-show动态组件组件根节点动效过程x-enter: 动效开始前(vue3 改为 x-enter-from)x-enter-active: show 动效结束前x-leave-active: hide 动效开始前x-leave-to: 动效结束后搭配手写的 css 动效，可以实现更多效果transition-group必须是多个子元素，每个子元素包含唯一的 key，子元素 show/hide 切换是无动效的，为了添加平滑动效，可以使用 x-moveDemo相关代码123456789101112131415161718&lt;transition-group name="g" tag="ul"&gt; &lt;li key="1"&gt;...&lt;/li&gt; &lt;li v-if="deviceData.type === '1'" class="formItem-height-12 l" key="2"&gt; &lt;FormItem prop="model" label="设备类型" :required="true"&gt; &lt;Select v-model="deviceData.model"&gt; &lt;Option v-for="(item, index) in deviceType" :key="index" :value="item.key" &gt;&#123;&#123;item.name&#125;&#125; &lt;/Option&gt; &lt;/Select&gt; &lt;/FormItem&gt; &lt;/li&gt; &lt;li key="3"&gt;...&lt;/li&gt; &lt;li key="4"&gt;...&lt;/li&gt; &lt;li key="5"&gt;...&lt;/li&gt;&lt;/transition-group&gt;1234567891011121314151617// 其他li位置移动时，动效平滑.g-move &#123; transition: transform 1s;&#125;// 设备类型 show/hide 动效变化方式.g-enter-active, .g-leave-active &#123; position: absolute; width: 432px;&#125;.g-enter, .g-leave-to &#123; opacity: 0; transform: translateX(30px);&#125;// 设备类型 动效平滑.l &#123; transition: all 1s;&#125;第三方动效库第三方库动效，通过 js 来调用，适用于较复杂的动效本次优化中使用到的第三方库有 animejs 和 lottieanimejs使用 js 即可编写复杂的动效使用文档Demo相关代码12345&lt;div class="login"&gt; &lt;div class="login-top"&gt;...&lt;/div&gt; &lt;div ref="lott" class="lottie"&gt;&lt;/div&gt; &lt;div class="user"&gt;...&lt;/div&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; import anime from 'animejs/lib/anime.es' export default &#123; mounted () &#123; // 必须在mounted Dom渲染后 setTimeout(() =&gt; this.initAnime(), 250) &#125;, methods: &#123; initAnime () &#123; anime.timeline(&#123;loop: false&#125;) .add(&#123; targets: '.logo-img, .logo-vertical', opacity: [0, 1], translateY: ['20px', 0], duration: 1000, easing: 'easeOutCubic' &#125;, 0) .add(&#123; targets: '.user', opacity: [0, 1], translateY: ['-34%', '-44%'], duration: 1000, easing: 'easeOutCubic' &#125;, 0) .add(&#123; targets: '.system-name .zh-cn, .system-name .en-us', translateY: ['20px', 0], opacity: [0, 1], duration: 1000, easing: 'easeOutCubic' &#125;, 0) .add(&#123; targets: '.lottie', opacity: 1 &#125;) &#125; &#125; &#125;&lt;/script&gt;lottielottie 是一种跨平台的动效方案。ui小姐姐设计好动效后，利用插件导出 json，然后使用不同平台的 lottie + 同一份 json 文件，即可实现不同平台下的相同动效，极大的降低了动效开发的成本。Demo相关代码1&lt;div ref="lott" class="lottie"&gt;&lt;/div&gt;12345678910111213import lottie from 'lottie-web'import loJson from '../../static/images/login/login-lottie3.json'initLottie () &#123; this.anim = lottie.loadAnimation(&#123; container: this.$refs.lott, renderer: 'svg', loop: true, autoPlay: true, animationData: loJson &#125;) this.$emit('animCreated', this.anim)&#125;其他资料前端动效库汇总]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪元素的妙用]]></title>
    <url>%2F2020%2F11%2F16%2Fpseudo-element%2F</url>
    <content type="text"><![CDATA[最近ui优化做的比较多，样式写久了，越来越觉得 伪元素 是真的好用，善用 伪元素 能极大的提高效率。下面总结下几种常用的伪元素用法：三角形业务场景下的一些样式垂直居中用法三角形在 css 中，border边框 是由上下左右四个三角形组成的，所以，设置 border 边框为 transparent ，再设置要显示的 border 颜色， 即可以显示出三角形。通过设置不同的 border 和 border-left 宽度，可以生成不同效果的三角形添加 border-radius ， 可以让 三角形变成扇形Demo相关代码123456&lt;div class="pseudo"&gt; &lt;div class="triangle1"&gt;&lt;/div&gt; &lt;div class="triangle2"&gt;&lt;/div&gt; &lt;div class="triangle3"&gt;&lt;/div&gt; &lt;div class="triangle4"&gt;&lt;/div&gt;&lt;/div&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.pseudo &#123; position: relative; top: 10px; width: 100%; height: 150px; border: 1px solid red; display: grid; grid-template-columns: repeat(auto-fill, 120px); justify-items: center; align-items: center; .triangle1 &#123; position: relative; width: 100px; height: 100px; &amp;:after &#123; content: ''; border-top: 40px solid green; border-right: 40px solid orange; border-left: 40px solid red; border-bottom: 40px solid blue; position: absolute; top: 10px; left: 10px; &#125; &#125; .triangle2 &#123; position: relative; width: 100px; height: 100px; &amp;:after &#123; content: ''; border: 40px solid transparent; border-left: 40px solid red; position: absolute; top: 10px; left: 10px; &#125; &#125; .triangle3 &#123; position: relative; width: 100px; height: 100px; &amp;:after &#123; content: '' border: 40px solid transparent; border-left: 80px solid red; position: absolute; top: 10px; left: 10px; &#125; &#125; .triangle4 &#123; position: relative; width: 100px; height: 100px; &amp;:after &#123; content: ''; border: 40px solid transparent; border-left: 40px solid red; border-radius: 50%; position: absolute; top: 10px; left: 10px; &#125; &#125;&#125;业务场景最近的项目中，有个需求是自适应的情况下，显示5列图标，每列之间用箭头连接。单独的图标自适应好做，flex 、 grid 布局都可以实现，但是图标间的 连接箭头 就不好做了，因为2个图标之间的距离，是不固定的….但是！如果用伪元素，这个问题就很容易解决了～Tips:1个 元素 只能有1个 伪元素 ，如果要使用多个 伪元素 ，就得用多个 元素divarrows-before.width 宽度多 10px ，是为了能和 arrows-after 重叠，视觉看起来虚线不断裂Demo相关代码1234567891011121314&lt;div class="home-menu"&gt; &lt;div :class="[&#123;'arrows-after': arrowsAfter&#125;, &#123;'arrows-before': arrowsBefore&#125;]"&gt;&lt;/div&gt; &lt;div :class="&#123;'arrows': arrowsBefore&#125;"&gt;&lt;/div&gt; &lt;div class="title" @click="clickIcon"&gt; &lt;div class="bg" :style="bgStyles"&gt;&lt;/div&gt; &lt;span class="sp"&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class="body"&gt; &lt;div v-for="(item, index) in values" :key="index" :class="bodyClass" :style="bodyStyle"&gt; &lt;p class="value"&gt;&#123;&#123;item.value&#125;&#125;&lt;/p&gt; &lt;p class="name"&gt;&#123;&#123;item.name&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div12345678910111213141516171819202122232425262728293031323334353637383940@arrows-border: #E6E6E6;@arrows-margin: 24px;@arrows-width: 8px;@bg-r: 60px;.arrows(@arrows-margin) &#123; .arrows-before:before &#123; content: ''; width: calc(~'50% - @&#123;bg-r&#125; / 2 - @&#123;arrows-margin&#125; - @&#123;arrows-width&#125; + 10px'); height: 0; border: 1px dashed @arrows-border; position: absolute; left: -10px; top: 30px; &#125; .arrows:after &#123; content: ''; width: 0; height: 0; border: @arrows-width / 2 solid transparent; border-left: @arrows-width solid @arrows-border; position: absolute; left: calc(~'50% - @&#123;bg-r&#125; / 2 - @&#123;arrows-margin&#125; - @&#123;arrows-width&#125;'); top: 27px; &#125; .arrows-after:after &#123; content: ''; width: calc(~'50% - @&#123;bg-r&#125; / 2 - @&#123;arrows-margin&#125; + @&#123;arrows-width&#125;'); height: 0; border: 1px dashed @arrows-border; position: absolute; right: -@arrows-width; top: 30px; &#125;&#125;.arrows(@arrows-margin);@media only screen and (max-width: 1600px) &#123; @arrows-margin: 12px; .arrows(@arrows-margin);&#125;垂直居中参考之前写的一篇文章，利用 父元素 的 伪元素 ，可以实现垂直居中相关代码12345&lt;div class="parent"&gt; &lt;div class="centered"&gt; 我是居中文字 &lt;/div&gt;&lt;/div&gt;1234567891011121314151617181920.parent &#123; width: 400px; height: 300px; border: 1px soild pink;&#125;.centered: &#123; width: 100px; height: 60px; border: 1px solid green; display: inline-block; vertical-align: middle;&#125;.parent::before &#123; content: ''; width: 0; height: 100%; background: #ccc; display: inline-block; vertical-align: middle;&#125;总结伪元素的用法还有很多，目前常用的暂时就这些，其他用法等用的多后再记录下来吧～]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript vue 实战(1)]]></title>
    <url>%2F2020%2F09%2F02%2Fts-in-vue-1%2F</url>
    <content type="text"><![CDATA[typescript 对 vue 2.x 的支持不是很好，但我们还是有必要学习一下。本文会列出 vue 中常用功能在 typescript 里的写法。基于类的组件单页面是以类的形式使用的，所以用 typescript 定义 vue 应使用下面的语法在 script 里添加 lang=&#39;ts&#39;在 Component里定义组件的 name1234567&lt;script lang="ts"&gt; import &#123; Component, Vue &#125; from 'vue-property-decorator' @Component(&#123; name: 'HelloTs' &#125;) export default class HelloTs extends Vue &#123;&#125;&lt;/script&gt;javascript 的代码代码如下：12345&lt;script&gt; export default &#123; name: 'HelloTs' &#125;&lt;/script&gt;引入其他组件使用 import 引入其他组件在 Component.components 里添加引入的组件在 html 模板里使用组件1234567891011121314151617&lt;template&gt; &lt;div class="main"&gt; &lt;Login&gt;&lt;/Login&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang="ts"&gt; import &#123; Component, Vue &#125; from 'vue-property-decorator' import Login from '@/components/Login.vue' @Component(&#123; name: 'HelloTs', components: &#123; Login &#125; &#125;) export default class HelloTs extends Vue &#123;&#125;&lt;/script&gt;基础属性data直接定义即可。12345@Componentexport default class HelloTs extends Vue &#123; public name: string = 'Jane' public age: number = 18&#125;prop使用 import 引入 Prop在 @Prop 装饰器中添加其他属性12345678910import &#123; Component, Prop, Vue &#125; from 'vue-property-decorator'@Componentexport default class HelloTs extends Vue &#123; @Prop() public name!: string @Prop(&#123; required: true, type: Number &#125;) public age!: Number @Prop(&#123; required: true, type: String, default: (x: string) =&gt; `China: $&#123;x&#125;`&#125;) public address!: string&#125;Computed直接使用 get 返回使用 set + get 定义可修改的 computed1234567891011121314export default class HelloTs extends Vue &#123; public name: string = 'Jane' public age: number = 18 // Computed get sayHi (): string &#123; return `hi $&#123;this.name&#125;` &#125; get showAge (): number &#123; return this.age + 2 &#125; set showAge (newAge: number) &#123; this.age = newAge &#125;&#125;Methods直接定义123456789import &#123; Component, Vue &#125; from 'vue-property-decorator'@Componentexport default class HelloTs extends Vue &#123; public name: string = 'Jane' public age: number = 18 public sayHi (name: string): void &#123; console.log(`hi $&#123;this.name&#125;`) &#125;&#125;WatchersWatch 的用法和 Javascript 中的 handler 语法类似使用 import 导入 Watch在 Watch 装饰器中添加 监听对象 和其他属性添加 handler 方法123456789101112131415161718import &#123; Component, Watch, Vue &#125; from 'vue-property-decorator'@Componentexport default class HelloTs extends Vue &#123; public name: string = 'Jane' public age: number = 18 public likes: object = &#123; sport: 'sing', color: 'blue' &#125; @Watch('likes', &#123; immediate: true, deep: true &#125;) public likesChanged (): void &#123; console.table(this.likes) &#125;&#125;Emit父组件接受 Emit 的参数为子组件 return的值 + Emit函数自身的参数使用 import 导入 Emit在 Emit 装饰器中添加 this.$emit(&#39;xxx&#39;) 的方法，如未添加，使用下面定义的函数A(用-分隔)执行完函数 A 后会自动调用 this.$emit(&#39;A&#39;,params) 方法在父组件调用 Emit12345678910111213// ./HelloTs.vue: 子组件import &#123; Component, Emit, Vue &#125; from 'vue-property-decorator'@Componentexport default class HelloTs extends Vue &#123; public name: string = 'Jane' public age: number = 18 @Emit('addToCount') public addToCount (x: number, y: number, z:number): number &#123; console.table(&#123; x, y, z &#125;) return x + y + z &#125;&#125;123456789101112131415161718192021// ./Father.vue: 父组件&lt;template&gt; &lt;div class="main"&gt; &lt;HelloTs @addToCount="addToCount"&gt;&lt;/HelloTs&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang="ts"&gt; import &#123; Component, Vue &#125; from 'vue-property-decorator' import HelloTs from './HelloTs.vue' @Component(&#123; components: &#123; HelloTs &#125; &#125;) export default class Father extends Vue &#123; public addToCount (total: number, x: number, y: number, z:number): void &#123; console.log(&#123; total, x, y, z &#125;) &#125; &#125;&lt;/script&gt;生命周期钩子直接使用12345678910import &#123; Component, Vue &#125; from 'vue-property-decorator'@Componentexport default class HelloTs extends Vue &#123; public name: string = 'Jane' public age: number = 18 public mounted () &#123; console.log('HelloTs mounted ~') &#125;&#125;MixinsMixins 文件 extends Vue引入文件 extends Mixins编写Mixins新建 mixin 文件夹新建 ProjectMixin.ts 文件，添加文件内容，和 .vue 中的 &lt;script&gt; 标签内一样123456789101112131415// @/mixin/ProjectMixin.tsimport &#123; Component, Vue &#125; from 'vue-property-decorator'@Componentclass ProjectMixin extends Vue &#123; public proName: string = 'My project' public setProjectName (newValue: string): void &#123; this.proName = newValue console.log('修改成功') &#125; public showProjectName (): void &#123; console.log('proName: ', this.proName) &#125;&#125;export default ProjectMixin引入Mixins使用 import 引入 Mixins引入 Mixins 文件 ProjectMixin.ts修改继承 extends Vue 为 extends Mixins(ProjectMixin)调用 ProjectMixin.ts 中的变量和方法123456789101112// @/components/HelloTs.vueimport &#123; Component, Mixins &#125; from 'vue-property-decorator'import ProjectMixin from '@/mixin/ProjectMixin'@Componentexport default class Father extends Mixins(ProjectMixin) &#123; public mounted () &#123; this.showProjectName() this.setProjectName('New Project Name') this.showProjectName() &#125;&#125;Vuex在 typescript 中使用 Vuex 需要引入2个包 vuex-module-decorators 和 vuex-class编写Vuex在 store 文件夹下新建 modules 文件夹在 modules 文件夹下新建 user.ts 文件user.ts 文件添加内容store.index.ts 内引入 user123456789101112131415161718192021222324// @/store/modules/user.tsimport &#123; VuexModule, Module, Mutation, Action &#125; from 'vuex-module-decorators'@Module(&#123; namespaced: true &#125;)class User extends VuexModule &#123; public vuexName: string = '' public vuexValue: string = '' get vuexValueUpper (): string &#123; return this.vuexName.toUpperCase() &#125; @Mutation public setName (newName: string): void &#123; this.vuexName = newName this.vuexValue = 'vuexValue: ' + this.vuexName &#125; @Action public updateName (newName: string): void &#123; this.context.commit('setName', newName) &#125;&#125;export default User123456789101112// @/store/index.tsimport Vue from 'vue'import Vuex from 'vuex'import User from './modules/user'Vue.use(Vuex)export default new Vuex.Store(&#123; modules: &#123; User &#125;&#125;)使用Vuex引入 vuex-class 中的 namespace定义 modules 常量定义及调用 Vuex1234567891011121314// @/components/HelloTs.vueimport &#123; Component, Vue &#125; from 'vue-property-decorator'import &#123; namespace &#125; from 'vuex-class'const user = namespace('User')@Componentexport default class HelloTs extends Vue &#123; @user.State public vuexName!: string @user.Getter('vuexValueUpper') public vUpper!: string @user.Action public updateName!: (name: string) =&gt; void&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>vue</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-i18n：vue下的一种多语言方案]]></title>
    <url>%2F2020%2F08%2F26%2Fvue-i18n%2F</url>
    <content type="text"><![CDATA[vue-i18n 是 vue 下的一个插件，用于让项目支持国际化多语言。安装1npm install vue-i18n --save引入vue-i18n将 vue-i18n 注入到vue中。注入后在任何 vue组件 (.vue结尾的文件)内，都可以使用 this.$t(&#39;xxxx&#39;) 来调用。新建 VueI18n 实例。新建默认语言。新建待翻译语言(json文件)。新建 VueI18n 实例时导入上面文件。新建 Vue 实例时引入 VueI18n 实例。1234567891011121314151617181920212223242526272829// ./i18n/index.jsimport Vue from 'vue'import VueI18n form 'vue-i18n'import 'en' from './i18n/locales/en.json'import 'zh' from './i18n/locales/zh.json'Vue.use(VueI18n)const DEFAULT_LANG = 'zh'const messages = &#123; en, zh&#125;const i18n = new VueI18n(&#123; locale: DEFAULT_LANG, messages: messages&#125;)export default i18n----------------------------// main.jsimport Vue from 'vue'import i18n from './i18n'new Vue(&#123; i18n&#125;).$mount('#app')使用官方文档有详情的介绍，本文只介绍常用的几种使用方法。json编写使用 {} 设置变量使用 @xx:yy:zz 引用 json 中已存在的变量12345678&#123; en: &#123; hello: 'hello &#123; name &#125;, nice to meet you ~', &#125;, en1: &#123; alsoHello: '@:en.hello' // 和en.hello一样，也要传入变量 &#123; name:xx &#125; &#125;&#125;使用场景vue实例中：1&lt;span&gt;&#123;&#123;$t('en.hello')&#125;&#125;&lt;/span&gt;12345// vue中的 &lt;script&gt;内hello () &#123; let hello = this.$t('en.hello') console.log(hello)&#125;非vue 实例中(比如js文件)：12345678// 注意没有$符号// ./demo.jsimport i18n from './i18n'hello () &#123; let hello = i18n.t('en.hello') console.log(hello)&#125;使用方式常规翻译直接使用即可。123456789// en.json&#123; en: &#123; hello: 'hello world' &#125;&#125;// hello.vuelet hello = this.$t('hello')带变量的翻译使用 {} 设置变量。使用 Object、Array 等传入变量。123456789101112131415161718192021// ---------- 对象// en.json&#123; en: &#123; hello: 'hello &#123; name &#125;, nice to meet you ~' &#125;&#125;// hello.vuelet hello = this.$t('en.hello', &#123; name: 'Jack' &#125;)// ---------- 数组// en.json&#123; en: &#123; hello: 'hello &#123; 0 &#125;, nice to meet &#123; 1 &#125; ~' &#125;&#125;// hello.vuelet hello = this.$t('en.hello', ['Jack', 'you'])优化调用方式我们发现，在 vue 组件中是通过 this.$t(&#39;xxx&#39;) 来调用，在 非vue 组件中是通过引入 i18n ，然后 i18n.t(&#39;xxx&#39;) 来调用。那每次调用的时候，我们得区分是否是 vue 组件， 然后重复、多次引入 i18n 。这明显增加了代码的复杂性。有个直接的解决方法就是，把 i18n 挂载到全局的 windows 下，之后在任何地方都可以通过 i18n.t() 来调用了。12345678910111213141516171819202122232425262728293031// ./i18n/index.jsimport Vue from 'vue'import VueI18n form 'vue-i18n'import 'en' from './i18n/locales/en.json'import 'zh' from './i18n/locales/zh.json'Vue.use(VueI18n)const DEFAULT_LANG = 'zh'const messages = &#123; en, zh&#125;const i18n = new VueI18n(&#123; locale: DEFAULT_LANG, messages: messages&#125;)window.i18n = i18n // +++++export default i18n----------------------------// main.jsimport Vue from 'vue'import i18n from './i18n'// 其他 import 文件 +++++new Vue(&#123; i18n&#125;).$mount('#app')添加修改语言方法我们在 i18n 里添加一个修改语言的方法。该函数做了以下3件事情。将当前语言保存到 localStorage 中；给 body 添加语种相关的 class，优化样式时使用。将当前语种存到 Vue 的全局配置中，以便未来使用。1234567891011121314151617181920212223242526272829303132333435363738394041// ./i18n/index.jsimport Vue from 'vue'import VueI18n form 'vue-i18n'import 'en' from './i18n/locales/en.json'import 'zh' from './i18n/locales/zh.json'Vue.use(VueI18n)const DEFAULT_LANG = 'zh'const messages = &#123; en, zh&#125;const i18n = new VueI18n(&#123; locale: DEFAULT_LANG, messages: messages&#125;)// 修改语言的函数export const setup = lang =&gt; &#123; if (!lang) &#123; lang = window.localStorage.getItem(LOCALE_KEY) if (!messages[lang]) &#123; lang = DEFAULT_LANG &#125; &#125; window.localStorage.setItem(LOCALE_KEY, lang) Object.keys(messages).forEach(lang =&gt; &#123; document.body.classList.remove(`lang-$&#123;lang&#125;`) &#125;) document.body.classList.add(`lang-$&#123;lang&#125;`) document.body.setAttribute('lang', lang) Vue.config.lang = lang i18n.locale = lang&#125;window.i18n = i18n export default i18n热加载(待验证)12345678910// main.jsif (module.hot) &#123; module.hot.accept(['./i18n/locales/en', './i18n/locales/zh'], function () &#123; i18n.setLocaleMessage('en', require('./i18n/locales/en').default) i18n.setLocaleMessage('zh', require('./i18n/locales/zh').default) // 同样可以通过 $i18n 属性进行热更新 // app.$i18n.setLocaleMessage('en', require('./i18n/locales/en').default) // app.$i18n.setLocaleMessage('ja', require('../i18n/locales/zh').default) &#125;)&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>vue</tag>
        <tag>多语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue Router]]></title>
    <url>%2F2020%2F06%2F29%2Fvue-router%2F</url>
    <content type="text"><![CDATA[断断续续看了好多遍 Vue Router 的官方文档，终于下定决心来写一篇笔记了…..OK，开始正题完整介绍的话内容太多，本文主要介绍工作中较常用到的几个知识点router/routerouterVue Router 对象，包含了 Vue Router 的一些属性和方法Vue Router 属性router.app: 配置了 router 的Vue根实例。router.mode: 路由使用的模式。router.currentRoute: 当前激活的路由实例，同 this.$route。Vue Router 方法router.beforeEach: 全局前置守卫，必须调用 next() 方法。router.beforeResolve: 全局解析守卫，必须调用 next() 方法。router.afterEach: 全局后置钩子，无 next() 方法。router.push: 打开一个新路由/页面，会在浏览器添加历史记录。router.replace: 打开/替换为一个新路由/页面，不会在浏览器添加历史记录。router.go: 前进 n 个页面，n 可为负数。router.back: 等同于 router.go(-1)。router.forward: 等同于 router.go(1)。router.getMatchedComponents: 返回目标位置或是当前路由匹配的组件数组(是组件的定义/构造类，不是实例)，一般用于服务端渲染的数据预加载使用。router.resolve: 解析目标位置。router.addRoutes: 动态添加更多的路由规则。router.onReady: 把一个回调排队。router.onError: 注册一个回调，该回调在路由导航过程中出错时被调用。route当前激活的路由实例，所有属性只读$route.path: 当前路由的绝对路径。$route.params: 当前路由上 key/value对象 参数。$route.query: 当前对象的 URL 上的 key/value对象 参数，会显示在浏览器地址栏上。$route.hash: 当前路由的 hash 值(带 #)。$route.fullPath: 完成解析后的 URL，包含查询参数和 hash 的完整路径。$route.matched: 一个匹配路由的数组。从根路由开始到当前所在路由的所有嵌套路径片段组成的数组。$route.name: 当前路由的 name。$route.redirectedFrom: 重定向来源的路由的名字。组件注入通过在 Vue 根实例的 router 配置传入 router 实例，下面这些属性成员会被注入到每个子组件。this.$router : router 实例。this.$route : 当前激活的路由实例，所有属性只读。导航守卫全局导航守卫beforeEach: 全局前置守卫，导航前，一定要调用 next() 来 resolve 这个钩子。beforeResolve: 全局解析守卫，导航前，和 beforeEach 类似，区别是导航在确认前，同时在所有组件内守卫和异步路由组件解析之后，解析守卫才会被调用。afterEach: 全局后置钩子，导航后，无 next() 方法也不会改变导航本身(可添加页面定位等功能)。路由独享的守卫beforeEnter: 路由独享守卫，配置在路由上的守卫，该路由及其子路由都会共享该守卫。组件内守卫beforeRouteEnter: 渲染该组件对应的路由被 confirm 前调用，不能获取 this，但可通过传回调(唯一一个可以传回调给 next 的守卫)给 next() 来访问组件实例。12345beforeRouteEnter (to, from, next) =&gt; &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;)&#125;beforeRouteUpdate: 路由改变，但是该组件被复用时调用。beforeRouteLeave: 导航离开该组件的对应路由时调用。123456789101112131415161718const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125;完整的导航解析流程导航被触发。在失活的组件里调用 beforeRouteLeave 守卫。调用全局的 beforeEach 守卫。在重用的组件里调用 beforeRouteUpdate 守卫（2.2+）。在路由配置里调用 beforeEnter 。解析异步路由组件。在被激活的组件里调用 beforeRouteEnter 。调用全局的 beforeResolve 守卫（2.5+）。导航被确认。调用全局的 afterEach 钩子。触发 DOM 更新。用创建好的实例调用 beforeRouteEnter 守卫传递给 next 的回调函数。其他falsy/falsey(虚值)在 Boolean 上下文中认定为 false 的值。Javascript 在需要用到 Boolean 类型的值的上下文中使用强制类型转换将值转换为 Boolean 值，比如条件语句和循环中。目前 Js 中只有7个 falsy 值：false、0、0n、&quot;&quot;/&#39;&#39;/、``、 null、undefined、NaN滚动行为scrollBehavior(to, from, savedPosition): 添加在路由实例 new Router({}) 中，用于自定义切换时页面如何滚动。该功能只在支持 history.pushState 的浏览器中可用。keep-alive 中无效，因为 keep-alive 已自动保留了之前的状态。返回滚动的位置信息：{ x: number, y: number } : 具体位置。{ selector: string, offset? : { x: number, y: number }} : 锚点+偏移量更多参考]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eslint && babel]]></title>
    <url>%2F2020%2F06%2F24%2Feslint-and-babel%2F</url>
    <content type="text"><![CDATA[关于eslint和babel的一点理解：eslint: 代码语法校验，主要是语法的使用是否正确，附带也可以格式化代码风格。babel: 转义代码，将浏览器不支持的新语法，转义成浏览器支持的语法。所以使用babel，我们就可以 毫无顾忌 的使用新语法了。但有时候吧，eslint 校验新语法时识别不了，就会报错了，这时候babel-eslint就登场了。babel-eslint: 将eslint无法识别的新语法转义成eslint可以识别的语法，进而通过eslint校验。babel-eslint需搭配eslint一起使用。题外话：babel有多种引入方式，最新的推荐方式是 按需转义格式化(统一)代码风格，还可以使用以下2种方式。主要是改变代码的显示风格，并不会对代码的语法规则做校验：.editorconfig: 本地配置文件，一般用于换行、缩进等。.prettierrc：当前主流的方法。所有规则基本都可配置。搭配 webstorm file watch 可实现 保存时自动格式化/提交代码时自动格式化]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种新的科学上网方式 -- v2ray]]></title>
    <url>%2F2020%2F01%2F05%2Fv2ray%2F</url>
    <content type="text"><![CDATA[由于某些众所周知的原因，emmmmm….，不久前的血色十月，一大波梯子被封了。毫无意外，我的 ss 也被封了，而且从那之后，ss 就变得不好用了，速度慢，还经常上不了网。然后吧，研究了下目前比较主流的方式 v2ray ，包括 搭建方式 、速度优化、ip伪装防封 等，发现 v2ray : ws + tls + nginx + cdn 的方式速度和伪装性都很好。再然后吧，今天就总结一下这个好了…..本文主要总结了以下几个方面：最终总结及推荐名词解释具体搭建流程效果相关资料介绍最终总结及推荐根据实际测试下来的结果，最终推荐 google云香港服务器+ws+tls+nginx+伪装主页+bbr 这种配置。不推荐使用 cdn 。因为免费的 cdn 虽然能隐藏真实ip，但是会 大大降低网络速度，再加上 ws+tls+nginx+伪装主页，已经能达到很好的欺骗 GFW 的效果了，而收费的 cdn 虽然效果好，但是太贵了！所以不推荐使用 cdn。服务器速度最快的供应商是 google云，其次是 搬瓦工，最后是 vultr。香港服务器最快(vultr没有香港服务器)。搬瓦工 服务器速度：香港服务器 &gt; CN2 GIA-E = CN2 GIA &gt; KVM = vultr 。协议mkcp 协议搭建简单，但是速度不够快，伪装还行，但在有些场合连接不稳定(比如 在公司网络 ，我就经常连不上….. )。ws+tls 协议搭建复杂一下，需要有域名，但是速度快，而且稳定，在公司网络，一样稳如老狗！！ws+tls+nginx+cdn 伪装性更好，但是更复杂，需要懂一些nginx的相关配置，还要会cdn代理伪装。不过不推荐 cdn 代理。原因之前说到了：免费的 大大降低网速，收费的太贵。(免费的cloudflare服务器在美国，ping 变成200+， 直连google云香港服务器 ping 才20+，速度差10倍)。ws+tls+nginx+主页伪装 已经能很好的伪装了，能 很好的骗过 GFW 了 。所以推荐的是 ws+tls+nginx+伪装主页。bbr加速bbr 是 google 的一种算法加速，对速度 影响极大，强烈推荐开启。就个人测试而言，同样配置 youtube 4K 60fps 下，未开启 bbr 速度为 20k Kbps，开启 bbr 后为 150k Kbps，速度相差极大。直接使用一键安装脚本里的命令开启即可，选择 bbrPlus版本，即 11-2-7 (2020.08.08更新)一键脚本的bbr安装启动命令已经失效，请使用下方新命令。名词解释一键安装脚本一键安装 v2ray+ws+tls+nginx+https证书+https证书定时续签。1bash &lt;(curl -L -s https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install.sh) | tee v2ray_ins.log相关路径：Web 目录：/home/wwwroot/3DCEListV2ray 服务端配置：/etc/v2ray/config.jsonV2ray 客户端配置: ~/v2ray_info.txtNginx 目录： /etc/nginx证书文件: /data/v2ray.key 和 /data/v2ray.crtcdn用来 伪装真实ip，还有防 DDOS流量攻击 等其他功能。cloudflare一个免费配置 cdn 的网站，但是不推荐使用，原因前面有说到，会 大大降低网络速度。wswebsocket ，一种协议。需要有域名。把翻墙流量伪装成正常访问配置域名的流量。tls一种加密协议，需要使用域名。一般配合 ws 使用。nginx(非必须)服务器配置 web网站 使用，配置一个 .html 文件 伪装成静态网站。https证书(非必须)给伪装的 web 网站添加证书，让网站更真实。证书有效期3个月，一键安装脚本 会自动 申请，下载证书，并添加 证书自动续签任务，但是，需要自己修改nginx配置，选择证书路径！！bbr一键安装脚本123wget -N --no-check-certificate "https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh"chmod +x tcp.sh./tcp.sh具体搭建流程申请域名可以在 freenom 申请免费的域名。不过这个网站注册比较麻烦…..也可以在 阿里云，腾讯云 等注册，都可以。配置cdn免费的话可以在 cloudflare 配置 cdn。配置时，代理 Proxy status 记得点成灰色，在 bbr 安装完成后，在决定点亮。点亮不点亮都可以使用，点亮即使用代理，伪装了真实ip，但速度会慢很多，不点亮即直连。配置好后，需要在 域名管理 的地方(比例如阿里云-&gt;域名-&gt;管理-&gt;cdn)，将 dns 的2个地址添加上去。创建vm实例使用主机供应商添加 vm实例即可，推荐 google云， 速度最快。以下以 google 为标准：创建 vm 实例选择 香港+N1+f1-micro+勾选http、https+网络标记rz,cz编辑防火墙规则 rz ：方向：入站；目标：网络中的实例；来源过滤条件：IP地址范围；来源IP地址范围：0.0.0.0/0编辑防火墙规则 cz：方向：出站；目标：网络中的实例；来源过滤条件：IP地址范围；来源IP地址范围：0.0.0.0/0一键脚本安装在 google云 vm实例 页面，点击 SSH 链接：输入 sudo -i 获取 root 权限；输入一键安装脚本1bash &lt;(curl -L -s https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install.sh) | tee v2ray_ins.log按要求输入域名，等待脚本执行完成即可。修改nginx配置文件(非必须)添加 nginx 命令到环境变量12echo PATH=$PATH:/etc/nginx/sbin &gt;&gt; /etc/profilesource /etc/profile下载并修改nginx配置文件窗口右上角下载，下载后编辑，主要修改 域名、端口号、/ptah、https证书路径可以参考下面的配置该配置做了以下几件事：重定向 http(80端口) 到 https(443端口)。重定向 /path 或 websocket 协议到 23188 端口，v2ray ws 协议用。修改 https证书路径。修改 域名、端口号。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133user root;worker_processes 3;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 4096;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name kxsw.jianwill.cn; return 301 https://kxsw.jianwill.cn:443; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /home/wwwroot/3DCEList; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # server &#123; listen 443 ssl http2; server_name kxsw.jianwill.cn; ssl_certificate /data/v2ray.crt; ssl_certificate_key /data/v2ray.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; location / &#123; root /home/wwwroot/3DCEList; index index.html index.htm; &#125; location /8fded3d7/ &#123; proxy_redirect off; proxy_pass http://127.0.0.1:23188; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header Host $http_host; proxy_intercept_errors on; if ($http_upgrade = "websocket" )&#123; proxy_pass http://127.0.0.1:23188; &#125; &#125; &#125;include conf.d/*.conf;&#125;上传nginx.conf配置文件窗口右上角，上传文件，上传后到文件默认在 /home/google用户名/ 路径下，比如我的是 /home/jian23333/拷贝nginx.conf到nginx配置目录nginx 配置文件路径是 /etc/nginx/conf/所以，执行下面的命令123cd /home/jian23333/cp nginx.conf /etc/nginx/conf/// 默认会直接覆盖PS： 如果上传的时候，已经存在 nginx.conf，上传的文件会被命名为 nginx_(n).conf，后面执行命令的时候 ( 这个符号可能会识别报错，这时可以删掉原来的所有 nginx_(n).conf 文件，重新上传，就命名成 nginx.conf 文件了。删除命令12cd /home/jian23333/rm *.conf校验并重新启动nginx校验：nginx -t重新启动：nginx -s reload查看nginx是否启动：ps -ef | grep nginx，看是否有 master 的行如果校验报错，根据错误提示，修改配置文件。可以使用 vi /etc/nginx/conf/nginx.conf 直接修改，也可以使用上面的方式下载到本地，修改，再上传的方式。如果提示 nginx: command not found ，就是没有把 nginx 配置到环境变量中，重新执行上面的 第一步：添加nginx命令到环境变量 即可。安装bbr加速安装bbr执行bbr一键安装脚本123wget -N --no-check-certificate "https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh"chmod +x tcp.sh./tcp.sh依次执行2-7，即安装bbrPlus，使用bbrPlus加速安装之后使用./tcp.sh即可重复执行命令期间会重启一次。经测试，发现 bbrPlus 比 bbr 加速效果更好。检查bbr是否安装成功验证当前TCP的控制算法(是否安装bbr)：1sysctl net.ipv4.tcp_available_congestion_control返回值一般为：123net.ipv4.tcp_available_congestion_control = bbr cubic reno// 或者net.ipv4.tcp_available_congestion_control = reno cubic bbr验证BBR是否已经启动(是否启动bbr)：1sysctl net.ipv4.tcp_congestion_control返回值一般为：1net.ipv4.tcp_congestion_control = bbr或者：1lsmod | grep bbr返回值一般为：123// 返回值有tcp_bbrplus 即说明bbr已经启动。// PS：但不是所有vps都会有此返回值，没有也正常。tcp_bbrplus 20480 21注意： bbrPlus 有时候会自动失效(比如重启服务器后？)，此时需手动再次开启bbrPlus其他问题如果要更换域名，发现域名证书没有一起更新怎么办？删掉证书文件，重新执行一键安装脚本，选择重新安装 ws+tls+nginx123456// 作废！作废！作废！cd /data/rm v2ray.crtrm v2ray.keybash &lt;(curl -L -s https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install.sh) | tee v2ray_ins.log1一键安装脚本已更新并添加删除证书遗留文件功能，执行一键安装脚本，选择16即可12bash &lt;(curl -L -s https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install.sh) | tee v2ray_ins.log16如何重启服务器1reboot效果bbr 加速后，youtube 4K 60fps ，速度可以达到 170k Kbps，网速 17m/s （我用的100M电信，稳定20k Kbps就可以流畅看 4K 60fps）。所以，现在是 秒开4K，8K用户体检极好！…而且还有伪装主页(https加密)地址为：kxsw.jianwill.cn相关资料介绍折腾了几个月，尝试了多家供应商不同地区的服务器，vultr 美国、巴黎、新加坡、日本等，google云 香港等，不同的协议 tcp、mckp伪装BT下载、mkcp伪装Facetime童话、mkcp伪装微信视频、websocket，cdn，nginx 等多种方案，最后决定使用 google云香港服务器+ws+tls+nginx+伪装主页 的方式。参考了很多资料，视频，下面为几个主要的。视频:v2ray+ws+tls+nginx文章:v2ray+ws+tls+nginx手动及一键脚本申请免费域名froomon免费cdn cloudflaregoogle云 gcpping测试]]></content>
      <categories>
        <category>一起哈啤</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
        <tag>vpn</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ss + proxifier 实现vpn游戏代理]]></title>
    <url>%2F2019%2F09%2F10%2Fsstovpn%2F</url>
    <content type="text"><![CDATA[之前搭过一个 ss (搭建教程可以参考 自建ss/ssr服务器教程)，但 ss 只能在浏览器上用，如果想像 vpn 一样代理游戏的话，该怎么办呢？好在这个问题已经有解决方案了，就是搭配 Proxifier 使用。下面，就是设置 Proxifier 的步骤。下载 ss 和 Proxifier下载 ssWindows SSR客户端 ：下载地址Mac SSR客户端 ：下载地址下载 ProxifierWindows 便携版 ：官网地址Windows 安装版 ：官网地址Mac版 ：官网地址实现步骤启动ss启动并设置好 ss ，保证能正常运行即可。启动并设置 Proxifier启动 Proxifier 后，要配置以下三个步骤：代理服务器设置代理规则设置域名解析设置代理服务器设置profile –&gt; Proxy Servers添加 Server设置 Address 和 Port修改 ProtocolCheckOK代理规则设置profile –&gt; Proxification Rules设置 Localhost设置 需要代理的游戏，比如 GTAV设置 默认连接方式域名解析设置profile –&gt; Name Resolution设置 通过代理服务器解析域名设置 不解析以下主机效果图下面是 ss + Proxifier 代理后，启动 GTAV 的效果图然后，终于可以愉快的体验 GTAV 赌场DLC 了…(手动狗头，滑鸡!)]]></content>
      <categories>
        <category>一起哈啤</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F05%2Fregexp%2F</url>
    <content type="text"><![CDATA[table{width:auto}研究了一下正则表达式理解的不深，但也有些心得所以做个总结～哈哈哈使用方法正则表达式在不同的语言有不同的使用方法一般都是 /^xxxx$/其中：// ：代表里面是正则表达式的匹配规则^ ：表示正则表达式的开始$ ：表示正则表达式的结束xxx ： 位于 ^ 和 $ 之间的为正则表达式规则，用于匹配字符串等理解说几个自身的理解吧特殊字符符号作用^开始标识。方括号 [ ] 中表示不包含对应的集合$结束标识[ ]用于匹配具体的值，比如 [A-Z] [A-Za-z] [0-9]( )用于整理表达式，确定匹配的优先级，类似数学中的 ()用于分组，可用$1，$2 … 获取对应分组里的内容{ }用于设置匹配次数，如未设置，默认为1次[竖杆]匹配两者中的一个，需用括号括起来，比如 (0[竖杆][1-9][0-9]*)\转义字符.匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \.限定符未使用限定符时，默认匹配1次符号作用*匹配前面的子表达式零次或多次。例如，zo 能匹配”z” 以及 “zoo”。 等价于{0,}。+匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。？匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。{n}n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。{n,}n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。{n,m}m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。其他\d ：数字大写为原来的反的值：\D ：除数字之外的所有值$1, $2… ：用于获取 () 对应分组里的内容，在 replace 等地方很常见。比如可以用 $1,$2,$3 获取年月日：/^(\d{4})[\/-](\d{1,2})[\/-](\d{1,2})$/ 。&#39;2020/01/16&#39;.replace(/^(\d{4})[\/-](\d{1,2})[\/-](\d{1,2})$/, &#39;$1-$2-$3&#39;)常用🌰0和非0开头的纯数字 ：/^(0|[1-9][0-9]*)$/非0开头的最多带两位小数的数字 ：/^([1-9][0-9]*)+(\.[0-9]{1,2})?$/带1～2位小数的正数或负数 ：/^(-)?([1-9][0-9]*)(\.d{1,2})?$/非负的整数或最多2位小数的数字(0.0, 0.00 未过滤掉) ：/^(0|([1-9][0-9]*))(\.[0-9]{1,2})?$/非负的整数或最多2位小数的数字+2位字母(0.0, 0.00及加字母 未过滤掉) ：/^(0|[1-9][0-9]*)(\.[0-9]{1,2})?([A-Za-z]{1,2})?$/推荐资料1. 常用的正则表达式大全2. 正则表达式 - 菜鸟教程3. FeHelper]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>后端</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx学习（1）]]></title>
    <url>%2F2019%2F08%2F25%2Fnginx-1%2F</url>
    <content type="text"><![CDATA[因为公司的需要，网站需要接入网关，对域名有校验于是研究了一下 nginx 和 代理发现还挺好玩的。。然后，就总结了一下这份nginx-1 ！简介nginx 的功能太多，简单来说就是可以配置相应的服务器。可以配置包括但不限于：代理域名过滤IP过滤等等其他，具体可以参考 中文文档 以及 英文文档安装mac 安装 nginx 很简单，先安装 homebrew ，然后安装 nginx安装 homebrew1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"出现以下 log 表示安装完成了1Installation successful!可以使用以下命令查看 homebrew 的版本123brew -vHomebrew 2.1.7Homebrew/homebrew-core (git revision 270f; last commit 2019-07-18)常用的 brew 命令brew 搜索软件 ：brew search nginxbrew 安装软件 ：brew install nginxbrew 卸载软件 ：brew uninstall nginxbrew 升级 ：sudo brew updatebrew 查看安装信息 ：sudo brew info nginxbrew 查看已安装软件 ：brew list安装 nginx安装 nginx1sudo brew install nginx启动 nginx 服务1sudo brew services start nginx利用 http://localhost:8080 进行访问，如果出现如下页面，说明 nginx 启动成功相关 文件地址host ：/private/etc/hostsnginx ：文件配置路径：/usr/local/etc/nginx/nginx.conf服务器默认路径：usr/local/var/www安装路径：/usr/local/Caller/nginx/1.17.1常用的 nginx 命令在任意路径下执行都可以！ 🤪启动：nginx / nginx -c /usr/local/etc/nginx/nginx.conf更新配置文件后重启：nginx -s reload校验配置文件：nginx -t停止：快速停止：nginx -s stop正常停止(执行完当前队列)：nginx -s quit查看是否启动 nginx：ps -ef|grep nginx ：查看是否有 master 的进程记住 第二列 的 pid 号 xxx，可以用来 杀进程停止(杀掉进程)：快速停止(立刻)：kill -TERM xxx正常停止：kill -QUIT xxx和上面一样：kill -INT xxx作用这里主要说下，在公司用到的，代理代理需求公司的后端接入了网关，对域名有校验，只有符合规则的域名才能调用网关于是，本地开发的时候，如果用 http://localhost:3001 去调开发环境的后端，会失败，因为通过不了网关所以，需要做一个代理，代理 xxx.ym 域名，当调用 / 的时候调本地的前端，当调用 /api 的时候调服务器上的后端，这样就能和开发环境的后端连调了步骤上面说了需求，那如果要实现这样效果，我们要执行以下几个步骤：配置 host 文件配置 nginx.conf 文件启动 nginx启动 前端开发环境使用 http://xxx.ym 地址进行测试配置 host 文件12# host 文件127.0.0.1 xxx.ym配置 nginx.conf 文件12345678910111213141516171819202122232425# nginx.conf 文件server &#123; listen 80; server_name xxx.ym; location / &#123; proxy_pass http://127.0.0.1:3001; &#125; location /api &#123; proxy_pass http://10.1.0.67:9523; proxy_set_header Host xxx.yy.ym; proxy_set_header X-Forward-For $remote_addr; &#125; location /oba3/api &#123; proxy_pass http://10.1.0.67:9523; proxy_set_header Host xxx.yy.ym; proxy_set_header X-Forward-For $remote_addr; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;启动或重启 nginx1234567// 启动nginx// 或重启nginx -s reload// 或先校验文件正确性，再重启nginx -tnginx -s reload启动前端环境12cd /xxxxnpm run dev打开网站在浏览器输入 http://xxx.ym 打开就可以啦搭配 host 文件搭配 host 文件，可以在本地 打开任意域名，跳转到任意想跳转的地址，包括但不限于跳转到 https://www.google.com，https://www.baidu.com，http://localhost:4000 等任意地址。我们可以这样理解：多个 server块 才会匹配 server_name ，1个话不匹配直接使用nginx 是服务器上用的，所以想像成服务器的话，1个服务器有1个ip，但是可以有多个 域名 解析成这个ip，所以当不同的域名访问这个服务器的时候，怎么区分不同的域名呢？，于是， server_name 这个字段就出现了，它可以使用 正则和通配符 来匹配域名，决定 哪个域名使用那个 server块，进而使用相应的配置。端口 相当于二次校验。然后可以使用 location / + prox_pass 进行代理通过配合 host 文件使用，host 文件可以将指定域名映射到指定ip，比如可以把任意网站xxx映射到 127.0.0.1 ，我们可以搭配nginx的 server块 的 端口号，然后进行代理，代理到任意 ip上举个🌰，下面的配置可以把 longge666.huiwan 映射成本地的 http://localhost:4000：123# host 文件# .com域名 chrome会自动转换成 https，跳转不了127.0.0.1 longge666.huiwan123456789101112131415# nginx.conf 文件server &#123; listen 80; server_name longge666.huiwan; location / &#123; proxy_pass http://localhost:4000; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;效果如下：其他对 nginx 的理解暂时就这么多后面有了新的理解再继续补充～ 😋]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[omp项目总结]]></title>
    <url>%2F2019%2F08%2F18%2Fomp%2F</url>
    <content type="text"><![CDATA[连续加班1个月了，天天加班10点多，到家11点半，周末也在加班，基本没有哪天是12点以前睡的。明显感觉扛不住了，身体越来越差，一度处于 猝死的边缘 …..好在这个项目终于完成了(其实还没完全结束，还在修bug阶段，然后又被安排去另一个项目了…7天开发时间，1个星期+2个周六，感觉要猝死了 …..)吐槽不要太多当然，收获也是很多所以，就总结了一哈….项目开发周期周期没啥好写的，就是1个月，从开发到上线，总共一个月…吐槽吐槽不要太多…开发周期太短，项目太赶了。最初计划是1个月时间上线。开发2周，测试联调2周，然而实际情况是，开发和测试同步进行。开发1个页面，测试就开始测，然后就是前期测试一直在催，页面开发好了没，开发好了没。。。 这 xx$%^^&amp;*， 开发怎么能赶上测试的进度….其次，开发预计时间，安排的极不合理。所有开发预计时间都是最理想状态的。就是没人打扰，不会遇到难点，只做开发一件事的时间。然而实际情况是，有太多的第三方因素会影响开发进度，比如：遇到难点：自己或者其他同事遇到难点，解决一个难点就花了2个人一上午的时间封装公共组件：这些任务是没有考虑在开发预计时间内的，那个时间只考虑了页面的开发时间…其他事情：比如开会，各种会议。测试叫去改bug等(测试和开发同步进行的….)后端接口有问题，联调的时候一直在等后端的接口正常总之就是，时间太赶，2周时间开发根本不够 。然后吧，就是疯狂加班了。。。住的离公司近还好，像我这种这么远的，每天10点多下班，回去到家就11点半了，每天要12点多才能睡觉，而且，长期没有休息，周末能休息下还好，问题是周末还得加班…..再然后吧，身体越来越差了，天天都困的要死，感觉要猝死了。。。所以，接下来，要赶紧改变下当前的状态，这是当前最重要的事了..收获ok，吐槽完毕，说下收获吧。花费了这么多精力，以及无数个加班。。。收获还是挺多的。。开发规范敏捷开发流程项目采用的是敏捷开发，和传统开发最大的区别，就是没有预期的开发时间。传统开发会有充足的开发计划，xxxx时间段开发，xxxx时间段测试阶段，然后上线。目的是 按时交付高质量的产品。而敏捷开发(omp项目就算吧)，是有需求了，立刻开发，并且 开发和测试同步进行，目的 最短时间内 交付产品。git使用规范：git-flow项目使用 git-flow 规范来管理代码，常见的分支结构有：master ：用来存储发布后的稳定代码分支，一般会使用 tag 标签进行管理hotfix-xxx ：热修复线上bug的分支，从 master 创建，直接合并到 masterdev ：开发分支，从 master 创建test ：测试分支，从 master 创建release ：发布分支，从 master 创建feature-xxx ：新需求分支，从 master 创建，合并到 dev其中有几点要求：一个功能一个分支，一起提交到远程服务器，待稳定后，删除对应的 feature 分支流程基本上是：master –&gt; feat-xx –&gt; dev –&gt; test –&gt; release –&gt; master不能从 dev merge 代码到 feature 分支，如果有依赖其他分支的功能从其他分支直接 merge 到当前分支：feat-A –&gt; feat-B代码方面vue生命周期及钩子函数vue 的生命周期包含下面8个阶段：beforeCreate ：vue 实例的挂载元素 $el 和数据对象 data 都是 undefined，还未初始化created ：完成了 data 的初始化，el 还未初始化beforeMount ：vue 实例的 $el 和 data 都初始化了，相关的 render 函数首次被调用。实例已完成以下的配置：编译模板，把 data 里面的数据和模板生成 html 。注意此时 html 还没有挂载到页面上mounted ：在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的 html 内容替换 el 属性指向的 DOM对象 。完成模板中的 html 渲染到 html 页面中，此过程中进行 ajax交互beforeUpdate ：在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前调用。可以在该钩子中进一步地更改状态，不会触发附加的渲染状态updated ：在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以依赖与 DOM 的操作。然而在大多数情况下应该避免在此期间更改状态，因为这可能会导致无限循环。该钩子函数在服务器端渲染期间不可用beforeDestroy ：在实例销毁之前调用。实例仍然完全可用destroyed ：在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子函数在服务器端渲染期间不被调用父子组件的传值父 –&gt; 子 ：用 props 传值可以设定 类型 和 默认值props 传的值在 data 里不能重复定义props 传的值默认会双向绑定，及 子页面的值改变了，会导致父页面值的改变，如果期望单向绑定，有2种方法解决这个问题：子页面data里定义 aa: props的值子页面使用 computed 的值子 –&gt; 父 ：用 this.$emit(&#39;aa&#39;, params) 传事件在父组件使用 @aa = &#39;yy&#39; 来捕获事件组件的封装太多了，后续补充…双向绑定的深刻理解（important！！）对象的双向绑定官网说明vue 中的双向绑定，只有在页面加载时，在 data 里定义了的对象，才能自动双向绑定，如果 data 里没有定义这个对象，直接修改 v-model 的值，对应组件的值(UI)是不会自动修改的。12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 是响应式的vm.b = 2// `vm.b` 是非响应式的如果要双向绑定未在 data 里定义的对象的属性，应该使用下面的方法添加单个属性 ：12// `Vue.set(object, propertyName, value)`Vue.set(vm.someObject, 'b', 2)12// `this.$set(object, propertyName, value)`，`this.$set` 是 `Vue.set` 的别名this.$set(this.someObject, 'b', 2)添加多个属性 ：直接使用 Object.assign() 或 _.extend() 添加到对象上的新属性不会触发更新。应该使用 原对象与要混合进去的对象的属性一起创建一个新的对象12// 代替 `Object.assign(this.someObject, &#123;a: 1, b: 2&#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123;a: 1, b: 2&#125;)数组的双向绑定官网说明数组：能双向绑定的情况变异方法(修改自身数组) ：push()pop()shift()unshift()splice()sort()reverse()非变异方法/替换数组(返回新数组) ：filter()concat()slice()使用 非变异方法 时，要使用一个新数组替换原数组123example1.items = example1.items.filter(function(item) &#123; return item.message.match(/Foo/)&#125;)数组：不能双向绑定的情况由于 JavaScript 的限制， Vue 不能 检测以下数组的变动：利用索引直接设置一个数组项的值，例如：vm.items[indexOfItem] = newValue修改数组的长度，例如：vm.items.length = newLength举个例子1234567var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的为了解决第一个问题，可以使用以下两种方式：1234// Vue.setVue.set(vm.items, indexOfItem, newValue)// vm.$setvm.$set(vm.items, indexOfItem, newValue)12// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue)为了解决第二个问题，可以使用 splice1vm.items.splice(newLength)iviewForm表单心得两点：validator 的使用reset 的使用table基本就是一些配置吧参考 iview table其他参考 iview 官网echartsecharts 要显示图表需要两个步骤初始化使用 setOption 方法更新数据所以对于 静态图表 来说，上面2个步骤可以放到一起对于 动态图表 来说，上面2个步骤则要分开，并且每次获取数据后(获取数据方式不限)需要使用 setOption 方法更新数据举个例子初始化图表初始化 websocketwebsocket获取对象并调用 setOption 方法更新图表vue-router跳转传值使用 query ：该模式下 to 的地址只能使用 path 而不能使用 name使用 params ：无要求12345&lt;!-- 命名的路由 --&gt;&lt;router-link :to="&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to="&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;"&gt;Register&lt;/router-link&gt;12345let params = &#123; type: 'add', code: 'aaa'&#125;this.$router.push(&#123;name: 'terminalEdit', params: params)跳转监听事件使用 watch 监听123456789101112watch: &#123; '$route' (to, from) &#123; // 跳转到当前页面和离开当前页面都会触发该监听事件 // 跳转到当前页面时，to.params 是获取的参数 // 离开当前页面时，from.params 是当前页的参数 let params = to.params if (params &amp;&amp; params.vehicleId) &#123; this.vehicleId = params.vehicleId this.init() &#125; &#125;&#125;在 mounted 的时候也可以添加捕获1234567mounted () &#123; let params = this.$route.params if (params &amp;&amp; params.vehicleId) &#123; this.vehicleId = params.vehicleId this.init() &#125;&#125;webpack后续补充….工具方面SourceTree分支的使用互相切换合并没啥好说的….pull注意项如果你本地有修改了但未 commit 的代码，这时候 git pull 的话，会提示 pull 下来的代码未提交(自动合并)，这时候，你 一定要提交 pull 下来的代码！！贮藏巧用 贮藏把当前未提交的代码贮藏起来，然后去做其他的任务，之后回来，随时启用贮藏的代码重置到之前的提交如果 commit 没有 push 到远程服务器，可以 重置到当前提交如果 commit 已经在 远程服务器上了，暂时还不知道怎么重置 …..WebStormeslint 配置 ：highLighting Level ：这个不能全局修改，有个替代的方法，把 warning 提示关掉，但并没有从根本上解决问题感受及总结技能方面说下接下来技能方面的计划吧感觉官方文档还是很重要的，比如上面说的，vue 中双向绑定无效，iview 中的 validator 和 reset 无效等问题，官网其实都有很好的描述。所以，再仔细过一遍官方文档，还是很有必要的。so，接下来几个要做的：vue-loader 官方文档vuex 官方文档TypeScript ：放后一步接下来的重心这个月基本就是在疯狂加班了，没时间做饭，没时间健身，没时间做任何事…所以，接下来有几点要改变的：减少加班学习新技能重新开始健身 (今年前5个月打卡了90天，6月到现在2个半月了吧，打卡不到10天….)题外话公司的椅子坐的好舒服。。。本来想买个公司同款的椅子(单买1k多一点)，然后卖家只对公，不卖给个人。。。然后 一怒之下 ，买个了3k的人体工程学椅子。。。emmmm…少去两次医院就回本了少去三次就赚了四次就血赚！！…然后，终于可以愉快的在家里加班了！…(๑•̀ㅂ•́)و✧]]></content>
      <categories>
        <category>日记本</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>vue</tag>
        <tag>git</tag>
        <tag>iview</tag>
        <tag>webpack</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下配置多个Git账户]]></title>
    <url>%2F2019%2F07%2F08%2Fmulti-git%2F</url>
    <content type="text"><![CDATA[默认情况下，我们使用 git 都是配置一个全局 user.name 和 user.email ，每次要用时使用该全局参数即可。但有时候，我们可能要同时使用多个不同的远程仓库，比如个人用的 github 使用 邮箱a ，公司用的 gitlab/gitea 使用 邮箱b ，等等。那么，如何在本地的Mac上配置多个git账户呢。我们继续往下看 ～需求起因起因很简单，就是因为自己一直用 github ，然后公司现在用 gitea 。然后，邮箱还不一样，也就是 生成的密钥 是不一样的，所以要配置多个 git 账号在一台电脑上。然后，就有了本文….相关细节关于 一台电脑使用多种类型远程仓库(github、gitlab、gitea 等)是否需要配多个git ，这里有几个细节需要说明：邮箱决定生成的密钥key是否一致；ssh 连接才需要密钥(配置)，http 连接不需要密钥/邮箱(配置)；对于未配置 user.name 和 user.email 的 git 账号，git 提交记录里默认使用当前电脑 登陆的用户名 和 电脑名 ；所以：如果使用 http 类型来 pull、push 代码，不需要配置！！如果多种类型的远程仓库，使用的是同一个邮箱，也不需要配置！！如果需要配置的话，需要配置每个项目的 user.name 和 user.email ，而 不能配置全局的 user.name 和 user.email 。配置步骤清除全局的 user.name 和 user.email一般情况下，可能之前已使用了以下脚本进行了全局配置：12git config --global user.name "xxx" // 配置全局用户名，如github上注册的用户名git config --global user.email "yyy" // 配置全局邮箱，如github上注册的邮箱如果不确定是否已经全局配置，可使用下面的命令进行查看：12git config --global user.namegit config --global user.email如果已经配置了，先删掉全局配置12git config --global --unset user.namegit config --global --unset user.email为每个账号生成一对密钥首先进入保存密钥的目录：1cd ~/.ssh // 进入目录，该目录下保存生成的密钥然后，根据 账号邮箱 生成 密钥 。1ssh-keygen -t rsa -C "xxx@qq.com"输入完成后，会有如下提示：12Generating public/private rsa key pair.Enter file in which to save the key (/Users/qiu/.ssh/id_rsa):这里要求对密钥进行命名。默认的文件名是 id_rsa 。为了方便区分，我们可以命名为 id_rsa_github 和 id_rsa_gitea ，接下来一直回车，直到密钥生成。每次生成的密钥都是成对的，比如 id_rsa_github 和 id_rsa_github.pub 。其中 id_rsa_github 是私钥，是保存在 本地 用来验证服务器的，不能泄露的；id_rsa_github.pub 是公钥，是添加到 托管网站 上的。私钥添加到本地SSH 协议的原理，就是在托管网站上使用 公钥 ，在本地使用 私钥 。这样本地仓库就可以和远程仓库进行通信了。上一步已经生成了 密钥文件 ，接下来需要使用 密钥文件 。首先是在本地使用 密钥文件 ：12ssh-add ~/.ssh/id_rsa_github // 将github私钥添加到本地ssh-add ~/.ssh/id_rsa_gitea // 将gitea私钥添加到本地为了校验本地是否添加成功，可以使用 ssh-add -l 命令进行查看对本地密钥进行配置由于添加了多个 密钥文件 ，所以需要对这多个密钥进行管理。在 .ssh 目录下新建一个 config 文件：1touch config文件中的内容如下：1234567891011Host github.com // 网站的别名，随意取HostName github.com // 托管网站的域名User xxx // 托管网站上的用户名IdentityFile ~/.ssh/id_rsa_github // 使用的密钥文件Port zz // 可选，端口// Gitea的配置相同Host git.ymHostName git.ymUser yyyIdentityFile ~/.ssh/id_rsa_gitea注意：config 文件中不允许有任何注释，所以 // 注释请删掉！Host 别名是用来替代 HostName 域名的，所以为了使原来的配置继续生效，建议 Host 设置成和 HostName 一样 。公钥添加到托管网站上以 github 为例先在本地复制公钥。进入 .ssh 目录，复制 id_rsa_github.pub 里的公钥。然后登陆 github，添加复制的公钥。可以使用以下命令来测试，是否配置成功：1ssh -T git@github.com如何使用如果是用远程仓库clone下来使用 SSH 协议也不用任何操作？(不确定，待跟进..)使用 HTTP 协议不需要任何操作，git clone 的时候会要求你输入 user.name 和 user.email 。PS：关于保存密码：第一次 git clone、git pull、git push 的时候会要求你输入密码，输入之后可以选择 永久保存 ，如果之后 github/gitlab/gitea 的账号密码修改了，在进行相应操作时会要求你重新输入密码。如果点了取消，以后每次 git pull、git push 都要输入用户名和密码，很麻烦…可以通过以下命令记住密码(仅限 http协议 )。输入 git config credential.helper store ，输入之后下次 git pull、git push 时会要求输入密码，输入一次后 git 就会一直记住了。如果是本地已有的仓库需要配置每个仓库的 user.name 和 user.email ：进入到对应仓库的目录下。执行以下命令：12git config user.name "xxx"git config user.email "yyy@qq.com"OK！大功告成 ！更新：hexo 中 git 记录正常，但直接部署的脚本 hexo d 异常，该脚本貌似使用全局参数？ 就是使用的全局 user.name 和 user.email ….关于如何修改 hexo d 使用当前项目的 user.name 和 user.email参考 能否hexo deploy 时指定git账户 #2125 。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重排重绘 与性能优化]]></title>
    <url>%2F2019%2F06%2F23%2Freflow-repaint%2F</url>
    <content type="text"><![CDATA[性能优化是个老生常谈的话题了，重排重绘也是性能优化的一种。减少或避免重排重绘，能有效地提升浏览器性能。那么，如何减少或避免重排重绘呢？本文将从 css 和 js 两个角度来分析 ～概念重排重排又叫 reflow ，指的是为了重新渲染部分或整个页面，重新计算页面元素的 位置 和 几何结构 的进程。简单来说，就是当元素改变的时候，将会影响文档内容或结构，或元素位置，此过程叫做 reflow 。reflow 是导致 DOM脚本 执行效率低下的关键因素之一。页面上任何一个节点触发了 reflow ，都会导致它的 子节点 和 祖先节点 重新渲染。那么，什么时候会导致 reflow 发生呢改变窗口大小改变文字大小添加/删除样式表内容的改变，（用户在输入框中输入内容也会）激活伪类，如 :hover操作 class 属性脚本操作 DOM计算 offsetWidth 和 offsetHeight设置 style 属性常见的重排元素widthheightpaddingmargindisplayborder-widthbordertoppositionfont-sizefloatbottomoverflow-yfont-weightoverleftfont-familyline-heightvertical-alignrightclearwhite-spacetext-alignmin-height重绘重绘又叫 repaint ，指的是当元素改变时，将不会影响元素在当前页面中的位置（比如 background-color，border-color，visibility），而仅仅会应用新的样式重绘此元素的过程。那么，什么时候会发生 repaint 呢常见的重绘元素colorborder-stylevisibilitybackgroundtext-decorationbackground-imagebackground-positionbackground-repeatoutline-coloroutlineoutline-styleborder-radiusoutline-widthbox-shadowbackground-sizejs方面的优化js方面主要是从 DOM 角度来优化重排重绘。包括以下几方面：文档片段使用 innerHTML服务端渲染使用事件代理减少 HTMLCollection 访问尽量不修改影响比较大的 DOM函数节流文档片段在多次操作 DOM 时，比如给一个 &lt;ul&gt; 元素添加多个 &lt;li&gt; 时，每添加一次 &lt;li&gt; 都会进行一次 现场更新(即reflow) 。使用 文档片段 的话，只会进行一次 现场更新(reflow) 。使用 appendChild() 时，只有 文档片段 的 子节点 会添加到目标，文档片段 本身不会被添加到目标。12345678910var list = document.getElementById('myList'), fragment = document.createDocumentFragment(), item, i;for (i=0;i&lt;10;i++) &#123; item = document.createElement('li'); fragment.appendChild(item); item.appendChild(document.createTextNode('item' + i));&#125;list.appendChild(fragment);使用 innerHTML先拼接好要渲染的 html字符串 。然后使用 innerHTML 进行一次渲染。1234567var list = document.getElementById('myList'), html = '', i = 0;for (i=0;i&lt;10;i++) &#123; html += '&lt;li&gt;item' + i + '&lt;/li&gt;/br';&#125;list.innerHTML = html;服务端渲染和 使用 innerHTML 类似，只是服务端会返回 拼接好的 html字符串 ，而不需要前端拼接 html字符串 了。然后直接使用 innerHTML 进行一次渲染即可。使用事件代理《JavaScript 高级程序设计》P675。页面上的 事件处理程序的数量 和 页面响应用户交互的速度 呈负相关。所以，如果减少 事件处理程序的数量 ，那 响应速度 将会更快。对于同一个事件，可以在 对应DOM 上定义，也可以在 父元素 上定义一大片事件，后者则是事件代理。减少 HTMLCollection 访问任何时候访问 HTMLCollection 都很耗资源。所以可以把要访问的 HTMLCollectionp[i] 存放到一个变量里，之后要用时直接访问变量。12345678var images = document.getElementsByTagName('img'), image, i, len;for (i=0,len=images.length;i&lt;len;i++) &#123; image = images[i]; // 一些操作&#125;尽量不修改影响比较大的 DOM尽可能限制 reflow 的影响范围，尽可能在低层级的 DOM 上进行操作。函数节流函数节流 的基本思想是，不能在没有间断的情况下(比如 onresize)连续重复执行某些代码，因为这可能导致浏览器崩溃。实现过程：第一次调用函数时，会创建一个 定时器 ，在指定的时间间隔之后再执行代码；第二次调用该函数时，会先清除前一次的 定时器 并 设置另一个 。目的是 只有在执行函数的请求停止了一段时间后才执行(新函数) 。123456// 未使用函数节流// 频繁的更新DOM，可能导致浏览器崩溃window.onresize = function() &#123; var div = document.getElementById('myDiv'); div.style.height = div.offsetWidth + 'px';&#125;12345678910111213141516// 使用函数节流// 只有前面函数停止一段时间后，才会执行第二个函数// 提高了性能function throttle(method, context) &#123; clearTimeout(method.Id); method.Id = setTimeout(function()&#123; method.call(context); &#125;, 100);&#125;function resizeDiv() &#123; var div = document.getElementById('myDiv'); div.style.height = div.offsetHeight + 'px';&#125;window.onresize = function() &#123; throttle(resizeDiv);&#125;css方面的优化css 方面的优化主要是指 非DOM 方面的优化。包括以下几方面：尽量使用 className 来一次修改样式，而不是高频的每次只修改一条样式。多次修改 DOM 样式时，可以使用 先改成display:none --&gt; 修改n次样式 --&gt; 最后改成display:xxx 。为动画的元素使用绝对定位 absolute 或 fixed ，减少附近元素的重排重绘。尽量少使用 table 。因为 table 一个单元格样式的改变，会导致整个 table 重排重绘，性能消耗巨大。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>css</tag>
        <tag>js</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平、垂直和完全居中]]></title>
    <url>%2F2019%2F06%2F22%2Fcentered%2F</url>
    <content type="text"><![CDATA[之前也总结过很多居中方法，但都没有写下来（对，我就是懒，加个书签就完事了…..）..然后吧 没有然后，每次要看的时候就很麻烦再然后吧，还是决定写下来好了…╮(╯▽╰)╭所以，本文将总结几种常用的水平、垂直和完全居中方法ok，正文开始！概述本文将介绍几种常用的水平、垂直和完全居中方法。主要方法有：3种绝对定位、flex、table、伪元素::after 等方法。后面的例子都以此 html 为样本。12345&lt;div class="parent"&gt; &lt;div class="centered"&gt; 我是居中文字 &lt;/div&gt;&lt;/div&gt;提示： 绝对定位+负margin、只使用绝对定位 和 绝对定位+transform 对应的9种居中里，有7种 position 值可以是下面任意一种组合。父元素为 position: relative ，子元素为 position: absolute 。父元素默认 position ，子元素为 position:relative 。剩下 只使用绝对定位(垂直居中) 和 只使用绝对定位(完全居中) 两种，position 只能使用 relative + absolute 的第一种方式。水平居中内联元素内联元素 直接使用 text-align: center 。12345.centered &#123; border: 1px solid green; display: inline; text-align: center;&#125;模拟table区块元素 模拟成 table ，然后使用 text-align: center 。1234567891011.parent &#123; width: 400px; height: 300px; border: 1px solid pink; display: table;&#125;.centered &#123; border: 1px solid green; display: table-cell; text-align: center;&#125;flex任何元素 改成 弹性盒子 类型，然后使用 justify-content: center 。1234567.parent &#123; width: 400px; height: 300px; border: 1px solid pink; display: flex; justify-content: center;&#125;绝对定位+负margin设置子元素：使用 left: 50% 定位到父元素水平中心，然后 margin-left: -xpx 向左偏移子元素 宽的一半 。1234567891011121314.parent &#123; width: 400px; height: 300px; border: 1px solid pink; position: relative;&#125;.centered &#123; width: 100px; height: 60px; border: 1px solid green; left: 50%; margin-left: -50px; /* 100px的一半 */ position: absolute;&#125;只使用绝对定位设置子元素 left: 0 ，right: 0 和 margin: x auto 来实现水平方向居中。12345678910111213.parent &#123; width: 400px; height: 300px; border: 1px solid pink;&#125;.centered &#123; width: 300px; /* 不确定 */ height: 60px; border: 1px solid green; left: 0; right: 0; margin: auto;&#125;绝对定位+translateX设置子元素： 使用 left: 50% 定位到父元素的水平中心，然后 transform: translateX(-50%) 向左偏移子元素 宽的一半 。1234567891011121314.parent &#123; width: 400px; height: 300px; border: 1px solid pink; position: relative;&#125;.centered &#123; width: 100px; height: 60px; border: 1px solid green; left: 50%; transform: translateX(-50%); position: absolute;&#125;垂直居中单行+行高固定设置 line-height 等于 height 。123456.centered &#123; width: 100px; height: 60px; line-height: 60px; border: 1px solid green;&#125;行高不固定设置上下 padding 相等。12345.centered &#123; width: 100px padding: 40px; /* 水平方向不能使用auto，即使我们只想设置垂直方向的padding */ border: 1px solid green;&#125;伪元素::before（推荐，技巧）利用父元素的 vertical-align: middle 属性来实现垂直居中。vertical-align 适用于 内联元素 ，所以子元素要设置成 display:inline 或 display:inline-block 。vertical-align 是相对 所有子元素垂直居中，如果有一个子元素的高度为 100%，那就会 相对父元素垂直居中 了 。所以，我们可以添加一个高度为100%的伪元素来达到这种效果。实现代码：1234567891011121314151617181920.parent &#123; width: 400px; height: 300px; border: 1px soild pink;&#125;.centered: &#123; width: 100px; height: 60px; border: 1px solid green; display: inline-block; vertical-align: middle;&#125;.parent::before &#123; content: ''; width: 0; height: 100%; background: #ccc; display: inline-block; vertical-align: middle;&#125;模拟table把元素模拟成 table ，然后使用 vertical-align: middle 来实现垂直居中。1234567891011.parent &#123; width: 400px; height: 300px; border: 1px solid pink; display: table;&#125;.centered &#123; border: 1px solid green; display: table-cell; vertical-align: middle;&#125;transform和 水平居中 类似，只是改成垂直方向。12345678910111213.parent &#123; width: 400px; height: 300px; border: 1px solid pink;&#125;.centered &#123; width: 100px; height: 60px; top: 50%; border: 1px solid green; transform: translateY(-50%); position: relative;&#125;flex利用 align-items: center 来实现 垂直居中 。align-self 也可以 垂直居中 。区别是 align-items 设置在 弹性容器 上，align-self 设置在 弹性子元素 上。align-content 也可以达到 垂直居中 的效果，但是必须设置 flex-wrap: wrap 或 flex-flow: xx wrap （wrap-reverse 也可）。1234567.parent &#123; width: 400px; height: 300px; border: 1px solid pink; display: flex; align-items: center;&#125;绝对定位和 水平居中 类似，分为 绝对定位+负margin、只使用绝对定位 和 绝对定位+translateY 三种。最后一种在上面 transform 已经介绍过了，这里只介绍前面两种。1234567891011121314151617/* 绝对定位+负margin 适用于 高度确定 的情况*/.parent &#123; width: 400px; height: 300px; border: 1px solid pink;&#125;.centered &#123; width: 100px; height: 60px; border: 1px solid green; top: 50%; margin-top: -30px; /* 60px的一半 */ position: relative;&#125;12345678910111213141516171819/* 只使用绝对定位 适用于 高度不确定 的情况*/.parent &#123; width: 400px; height: 300px; border: 1px solid pink; position: relative;&#125;.centered &#123; width: 100px; height: 60px; /* 不确定 */ border: 1px solid green; top: 0; bottom: 0; margin: auto; position: absolute;&#125;完全居中完全居中 就是把 水平居中 和 垂直居中 组合起来，使用的大部分方法前面都已经介绍过了。元素高度确定绝对定位+负margin使用 left: 50% 和 top: 50% 定位到父元素的完全中心，然后使用 margin-left:-xpx 和 margin-top: -ypx 来水平和垂直偏移子元素 一半的宽高 。123456789101112131415.parent &#123; width: 400px; height: 300px; border: 1px solid pink;&#125;.centered &#123; width: 100px; height: 60px; border: 1px solid green; left: 50%; top: 50%; margin-left: -50px; margin-top: -30px; position: relative;&#125;元素高度不确定只使用绝对定位使用 left: 0、top: 0、right:0、bottom: 0 和 margin: auto 来设置成 完全居中 。position 只能使用 relative + absolute 这种。1234567891011121314151617.parent &#123; width: 400px; height: 300px; border: 1px solid pink; position: relative;&#125;.centered &#123; width: 100px; height: 60px; border: 1px solid green; left: 0; top: 0; right: 0; bottom: 0; margin: auto; position: absolute;&#125;绝对定位+translate使用 left: 50% 和 top: 50% 来定位到父元素的完全中心，然后使用 transform: translate(-50%, -50%) 向左上偏移子元素 宽高的一半 。1234567891011121314.parent &#123; width: 400px; height: 300px; border: 1px solid pink;&#125;.centered &#123; width: 100px; height: 60px; border: 1px solid green; left: 50%; top: 50%; transform: translate(-%50, -50%); position: relative;&#125;模拟table模拟成 table ，然后使用 text-align: center 和 vertical-align: middle 来达到 完全居中 。123456789101112.parent &#123; width: 400px; height: 300px; border: 1px solid pink; display: table;&#125;.centered &#123; border: 1px solid green; display: table-cell; text-align: center; vertical-align: middle;&#125;伪元素::before（推荐，技巧）水平方向使用 dispaly:inline-block 和 text-align: center 来实现。垂直方向使用 ::before 伪元素来实现。1234567891011121314151617181920.parent &#123; width: 400px; height: 300px; border: 1px solid pink; text-align: center;&#125;.center &#123; width: 100px; height: 60px; border: 1px solid green; display: inline-block; vertical-align: middle;&#125;.parent::before &#123; content: ''; width: 0; height: 100%; display: inline-block; vertical-align: middle;&#125;flex使用 justify-content: center 来水平居中。使用 align-items: center 来垂直居中。align-self 和 align-content 也可用来垂直居中，只是前者要使用在 弹性子容器 上，后者要添加 flex-wrap: wrap （或相关）。12345678910111213.parent &#123; width: 400px; height: 300px; border: 1px solid pink; display: flex; justify-content: center; align-items: center;&#125;.centered &#123; width: 100px; height: 60px; border: 1px solid green;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 webpack]]></title>
    <url>%2F2019%2F06%2F16%2Fwebpack%2F</url>
    <content type="text"><![CDATA[webpack 是一个现代 JavaScript 应用程序的静态模块打包器。当使用 webpack 打包时，webpack 会从一个或多个入口处，递归地构建一个 依赖关系图(dependency graph) ，其中包含应用程序所需要的所有模块，然后打包成一个或多个 bundle 文件。webpack 可以打包 js、css、sass、less 、typescript、图片 等文件，默认只能打包 js 格式的文件，其他格式的文件需要加载 loader 后再打包。编写本文的时候，webpack 的最新版为 v4.34.0 。概念webpack 可使用 终端/命令行 来执行，当然，webpack 还是 高度可配置的 。webpack 有以下四个 核心概念 ：入口(entry)输出(output)loader插件(plugins)入口(entry)webpack 打包时的入口；可以有一个或多个入口；入口会依赖其他文件，webpack 会以此为依据，进而找到其他依赖的文件和关系，然后一起打包成一个或多个 bundle.js 文件；123module.exports = &#123; entry: './app/main.js'&#125;;出口(output)用于描述打包后的 bundle.js 文件的存放路径和命名规则，默认值为 ./dist ；1234567891011const path = require('path');module.exports = &#123; entry: './app/main.js', output: &#123; path: path.resolve(__dirname, 'public'), // 等效于 path: __dirname + '/public', filename: 'bundle.js' &#125;&#125;;// __dirname 是node.js的一个全局变量，表示当前执行脚本所在的目录loaderloader 能够让 webpack 打包那些 非javascript 文件；loader 需要单独安装并在 webpack.config.js 中的 modules 关键字下进行配置，loader 的配置包括以下几个方面：test ：一个用以匹配 loader 所处理文件的扩展名的正则表达式(必须) ；loader use ：loader 的名称(必须) ；include/exclude ：手动添加必须处理的文件(文件夹) 或屏蔽不需处理的文件(文件夹) ；query ：为 loader 提供额外的处理选项 ；更多信息 ；123456789module.exports = &#123; ... module: &#123; rules: [ &#123; test: /\.css/, use: 'css-loader' &#125;, &#123; test: /\.ts/, use: 'ts-loader' &#125; ] &#125;&#125;;插件(plugins)loader 被用来转换某些类型的模块，而插件则用来执行范围更广的任务；插件的范围包括：打包、优化、压缩、重新定义环境中的变量等其他功能；插件的使用和 loader 类似，先使用 npm 安装，然后在 webpack.config.js 中的 plugins 关键字下添加该插件的一个实例( plugins 是一个数组 )。更多信息 ；12345678910111213module.exports = &#123; ... module: &#123; rules: [ &#123; test:/\.css/, use: 'css-loader' &#125;, &#123; test:/\.ts/, use: 'ts-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;) ]&#125;;其他要点webpack 可配置的可使用 终端/命令行 来执行 webpack，也可配置好 webpack.config.js，然后直接使用 webpack 命令；全局安装的使用 webpack 命令，非全局安装的使用 node_modules/.bin/webpack 命令；这个命令会自动引用 webpack.config.js 文件中的配置选项；如果没有 webpack.config.js 配置文件，也可使用下面的命令来打包；1234567891011// 未配置 webpack.config.js// npx webpack &#123;入口&#125; -o &#123;出口&#125;npx webpack app/main.js -o public/bundle.js// 已配置 webpack.config.js，未配置 package.jsonnpx webpack --config webpack.config.jsnpx webpackwebpack// 已配置 webpack.config.js，已配置 package.jsonnpm startscript 脚本命令命令配置在 package.json 中的 scripts 关键字中；start 是 特殊的脚本命令，使用 npm start 即可，其他脚本 xx ，则需使用 npm run xx 来执行，比如 npm run build ；12345678910111213141516171819&#123; "name": "webpackdemo1", "version": "1.0.0", "description": "webpack sample project", "private": true, "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "webpack", "server": "webpack-dev-server --open" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.34.0", "webpack-cli": "^3.3.4", "webpack-dev-server": "^3.7.1" &#125;&#125;生成 Source Maps （使调试更容易）source maps 提供了一种对应编译文件和源文件的方法，使编译后的代码可读性更高，更容易调试；在 webpack.config.js 中的 devtool 关键字添加 devtool 选项即可，一般使用 source-map ；12345678module.exports = &#123; devtool: "source-map", entry: __dirname + '/app/main.js', // 已多次提到的唯一入口文件 output: &#123; path: __dirname + '/public', // 打包后文件存放的路径 filename: 'bundle.js' // 打包后输出的文件名称 &#125;,&#125;;更多信息 ；webpack 构建本地服务器（支持 模块热替换）webpack 可构建本地服务器，然后可配置一系列相关的设置；本地服务器支持 模块热替换 功能，即修改 JS 代码后，浏览器会自动刷新页面；使用方法：安装 webpack-dev-server 组件；1npm install --save-dev webpack-decv-server在 webpack.config.js 中的 devServer 关键字中进行配置；12345678module.exports = &#123; ... devServer: &#123; contentBase: './public', // 本地服务器所加载的页面所在的目录 historyApiFallback: true, // 不跳转 inline: true // 实时刷新 &#125;&#125;在 package.json 中的 scripts 中添加对应的命令( server 命令 )；12345"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "webpack", "server": "webpack-dev-server --open"&#125;在 终端/命令行 输入 npm run server 即可启动服务器；更多信息：使用webpack构建本地服务器使用 webpack-dev-server实例新建项目123mkdir webpackdemocd webpackdemonpm init安装 webpack 和 webpack-cli1npm install webpack webpack-cli --save-dev配置 webpack新建 app 文件夹，用来存放 js 源文件；新建 public 文件夹，用来存放 html 文件和打包生成的 bundle.js 文件；当前项目结构如下：配置 webpack 的 入口和出口，如下：1234567891011121314// webpack.config.jsmodule.exports = &#123; devtool: "source-map", entry: __dirname + '/app/main.js', // 已多次提到的唯一入口文件 output: &#123; path: __dirname + '/public', // 打包后文件存放的路径 filename: 'bundle.js' // 打包后输出的文件名称 &#125;, devServer: &#123; contentBase: './public', // 本地服务器所加载的页面所在的目录 historyApiFallback: false, // 不跳转 inline: true // 实时刷新 &#125;&#125;;配置 script 命令123456// package.json"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "webpack", "server": "webpack-dev-server --open"&#125;,编写代码在 /app 文件夹中添加 Greeter.js 和 main.js 文件；在 /public 文件夹中添加 index.html 文件；文件内容分别如下：123456// Greetet.jsmodule.exports = function () &#123; var greet = document.createElement('div'); greet.textContent = "Hi there are greetings!"; return greet;&#125;;123// main.js 入口文件const greeter = require('./Greeter');document.querySelector('#root').appendChild(greeter());123456789101112&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;运行打包生成 bundle.js 文件；1npm start启动服务器；1npm run server推荐文章1. [推荐]官方文档2. [版本较旧]入门Webpack，看这篇就够了]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>js</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise 相关简介]]></title>
    <url>%2F2019%2F06%2F14%2Fpromise%2F</url>
    <content type="text"><![CDATA[promise 是 ECMAScript6 新加的一个概念。本文将使用简洁的文字介绍 promise ，仅介绍大概情况。更多详情请参考结尾的推荐文章。好了，正文开始 ！简介Promise 是抽象 异步操作 对象以及对其进行一系列操作的组件。Promise 最大的功能是把 异步操作 变为 同步操作 。即只有 异步操作 完成后，才进行后面的操作。Promise 定义了一组 上述操作 相关的接口和方法，直接使用即可。Promise 状态使用 new promise 实例化的 promise对象 有以下三个状态：Fulfilledresolve(成功) 时，此时会调用 onFulfilled 。Rejectedreject(失败) 时，此时会调用 onRejected 。Pending既不是 resolve 也不是 reject 状态，也就是 promise 对象刚被创建后的初始化状态。方法创建 promise 实例创建实例有三种方法：new Promise() ；Promise.resolve ；Promise.reject ；12345678910111213141516171819// 方法1var promise1 = new Promise(function(resolve, reject) &#123; resolve('11'); reject(new Error('22'));&#125;);// 方法2var promise2 = Promise.resolve('1');// 等效于var promise2 = new Promise(function(resolve) &#123; resolve('1');&#125;);// 方法3 var promise3 = Promise.reject('2');// 等效于var promise3 = new Promise(function(null, reject) &#123; reject('2');&#125;);resolvePromise.resolve ：创建实例；返回 promise 对象，主要分下面3种情况：接收参数为 promise 对象：返回的还是接收到的 promise 对象；接收参数为 thenable 类型的对象：返回一个新的 promise 对象，这个对象有具有一个 .then 方法。更多 thenable 的信息，点我查看 ；接收参数为 其他类型 ：返回一个将该对象作为值的新的 promise 对象；rejectPromise.reject ：创建实例；返回一个使用了接收到的值进行了 reject 的新的 promise 对象；传给 Promise.reject 的值应该是一个 Error 类型的对象；另外，和 Promise.resolve 不同的是，即使 Project.reject 接收的是一个 promise 对象，该函数也还是会返回一个全新的 promise 对象；thenpromise.then ：promise 中最常用的方法；在 promise 对象变为 resolve 或 reject 后，执行相应的回调函数；then 中 return 的值，作为参数传入 链式方法 里的下一个方法；1234567891011121314// 常规用法var promise = new Promise(function(resolve, reject) &#123; //... resolve('11'); reject(new Error('Boom!'));&#125;);promise.then(function(value) &#123; console.log(value) // 11&#125;, function(error) &#123; console.log(error);&#125;)// 链式调用 return 的值作为下一个方法的参数// 见后面 链式方法catchpromise.catch ：处理异常的方法，和 reject 类似；包含 promise 对象变为 reject 、手动 throw new Error() 、系统抛出异常 三种情况；推荐使用 catch ，因为对于 then(f1,f2).catch() 这种情况，如果 f1 抛出异常，f2 是捕获不了的，链式方法后面的 catch 才能捕获到，或者改成 then(f1,f2).then(null,f3) 这样，f3 也能捕获到；1234567891011121314151617181920212223242526272829// 常规用法var promise = Promise.reject(new Error("BOOM!"));promise.catch(function(value) &#123; console.log(value); // Error: BOOM!&#125;)// 等效于 rejectpromise.then(function(value)&#123; console.log(value);&#125;,function(error)&#123; console.log(error);&#125;)// 等效于下面的写法，推荐用下面的写法promise.then(function(value)&#123; console.log(value);&#125;).catch(function(error)&#123; console.log(error);&#125;)// 推荐用 catch 的原因： reject 和 catch 都只能捕获上一级的错误// 如果用 reject 的话，同级的 resolve 中抛出异常的话，reject 就不能捕获了// 而如果用 catch 话，因为 catch 是链式方法的下一级，所以可以捕获到上一级 resolve 中的异常// 用链式方法 + reject 的话也行，效果和 catch 一样// 下面的写法，和上面的 catch 方法效果一样，不过一般不这样写，一般用 catchpromise.then(function(value)&#123; console.log(value)&#125;).then(null, function(error)&#123; console.log(error);&#125;)allPromise.all ：传入一个 promise 对象的数组作为参数。只有当数组里的 所有 promise 对象 全部 变为 resolve 时，才会调用 then 里相应的回调函数方法，then 参数为 所有 promise 返回值组成的 数组。只要有一个 promise 对象变为 reject ，就会调用 catch 里的回调函数方法，catch 参数为 reject 的 promise 返回值。数组中的多个 promise 一起 同时开始，并行执行 。所以顺序是：(arr[0] | arr[1] | arr[2+...]) --&gt; then 或者 arr[0] | arr[1] --&gt; catch | arr[2+...] 。12345678910111213141516171819202122var promise1 = new Promise(function(resolve, reject)&#123; //... resolve('1'); reject(new Error('Boom!'));&#125;);var promise2 = new Promise(function(resolve, reject)&#123; //... resolve('2'); reject(new Error('Boom!'));&#125;);var promise3 = new Promise(function(resolve, reject)&#123; //... resolve('3'); reject(new Error('Boom!'));&#125;);var promises = [promise1, promise2, promise3];Promise.all(promises).then(function(value)&#123; console.log(value); // ["1", "2", "3"]&#125;).catch(function(error)&#123; console.log(error);&#125;);racePromise.race ：和 Promise.all 类似，区别是 只要有一个 promise 对象变为 resolve 或 reject 时，就会调用 then 或 catch 方法；数组中的多个 promise 一起 同时开始，并行执行 （所以第一个执行完的不一定是 arr[0]）。then/catch 方法的参数为第一个执行完的 promise 返回的值。所以顺序是：arr[x] --&gt; then/catch | arr[0] | arr[1] | arr[2+...] 。12345678910111213141516171819202122var promise1 = new Promise(function(resolve, reject)&#123; //... resolve('1'); reject(new Error('Boom!'));&#125;);var promise2 = new Promise(function(resolve, reject)&#123; //... resolve('2'); reject(new Error('Boom!'));&#125;);var promise3 = new Promise(function(resolve, reject)&#123; //... resolve('3'); reject(new Error('Boom!'));&#125;);var promises = [promise1, promise2, promise3];Promise.race(promises).then(function(value)&#123; console.log(value); // 1&#125;).catch(function(error)&#123; console.log(error);&#125;);allSettledES2020 提出的新方法。和 Promise.all 、Promise.race 类似，区别是无论每个 promise 是 resolve 还是 reject，只有当 所有 promise 都执行完成 后，才会调用 then 函数。then 函数的参数为一个数组，该数组包含原 promises 集中每个 promise 的结果。对于每个结果对象，都有一个 status 字符串。如果它的值为 fulfilled，则结果对象上存在一个 value 。如果值为 rejected，则存在一个 reason 。value（或 reason ）反映了每个 promise 决议（或拒绝）的值。12345678910const promise1 = Promise.resolve(3);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'foo'));const promises = [promise1, promise2];Promise.allSettled(promises). then((results) =&gt; results.forEach((result) =&gt; console.log(result.status)));// expected output:// "fulfilled"// "rejected"Advancedcatch 和 reject 是一样的上面已经说过，catch 和 reject 是一样的，只是写法不同；不过从 链式方法 的写法角度来说，catch 写在下一级，能够捕获上一级中 reject 无法捕获的 resolve 中的异常，所以，推荐使用 catch 写法；thenablethenable 指的是一个具有 .then 方法的对象；Promise.resolve 可以将 thenable 对象转换为 promise 对象，返回的是一个新的 promise 对象；更多 thenable 的信息，点我查看 ；链式方法由于 then 和 catch 都返回了一个新的 promise 对象，因此它们可以用 . 的方式进行链式调用；then 返回的是新的 promise 对象，then 里面的方法返回的是 链式方法中下一个方法的传入参数；更多详情，点我查看 ；1234567891011// then 返回的 bpromise 是一个 promise 对象// then 里面函数返回的 value1*2 是链式方法中下一个方法的传入参数(value2)var apromise = new Promise(function(resolve) &#123; resolve(100);&#125;);var bpromise = apromise.then(function(value1)&#123; return value1 * 2;&#125;);bpromise.then(function(value2) &#123; console.log(value2); // 200&#125;)示例使用 ajax + promise 来读取并操作数据123456789101112131415161718192021222324function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var xhr = new XMLHttpRequest(); xhr.open('GET', URL, true); xhr.onload = function () &#123; if (xhr.status === 200) &#123; resolve(xhr.responseText); &#125; else &#123; reject(new Error(xhr.statusText)); &#125; &#125;; xhr.onerror = function () &#123; reject(new Error(xhr.statusText)); &#125;; xhr.send(null); &#125;);&#125;// 运行示例var url = "http://httpbin.org/get";getURL(url).then(function onFulfilled(value) &#123; console.log(value);&#125;).catch(function onRejected(error) &#123; console.log(error);&#125;);更多资料[推荐]JavaScript Promise迷你书（中文版）快来使用ES2015的Promise吧ES6 Promise 对象JavaScript Promise 对象]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[严格模式 的特别之处]]></title>
    <url>%2F2019%2F06%2F13%2Fstrict-mode%2F</url>
    <content type="text"><![CDATA[严格模式 是 ECMAScript5 引入的一个概念。通过严格模式，可以在函数内部选择进行较为严格的全局或局部的错误条件检测。使用严格模式的好处是可以提早知道代码中存在的错误，及时捕获一些可能导致编程错误的 ECMAScript 行为。那么，严格模式 和 非严格模式 有什么区别呢？我们一起往下看 ～如何使用使用 &quot;use strict&quot;; (注意后面的分号) ；支持 严格模式 的引擎会启动这种模式，不支持 严格模式 的引擎会忽略这个 编译指示 ；可以写在全局作用域(函数外部)，也可以写在函数内部。建议写在函数内部；区别1. 不允许意外创建变量1234// 未声明变量// 非严格模式模式：创建全局变量// 严格模式：抛出 ReferenceErrormessage = "Hello world";2. 不能对变量调用delete操作符12345// 删除变量// 非严格模式：忽略，静默失败// 严格模式：抛出 ReferenceErrorvar color = "red";delete color;3. 变量名限制不能使用 implements、interface、let、package、private、protected、public、static、yield 作为变量名；非严格模式 下可使用；4. 操作对象限制一般来说，非严格模式 下会静默失败，即忽略；严格模式 下会抛出错误；以下情况操作对象的属性会导致错误( 严格模式 下) ：为 只读属性 赋值会抛出 TypeError ；对 不可配置 的属性使用 delete 操作符会抛出 TypeError ；对 不可扩展 的对象添加属性会抛出 TypeError ；使用 对象字面量 时，属性名要唯一；1234567// 重名属性// 非严格模式：没有错误，以第二个为准// 严格模式：抛出语法错误var person = &#123; name: "Nicholas", name: "Greg"&#125;;5. 函数参数唯一严格模式 下要求命名函数的参数名必须唯一；123456// 重名参数// 非严格模式：没有错误，只能访问第二个参数// 严格模式：抛出语法错误function sum(num, num) &#123; // do something&#125;6. 修改参数的值不会反映到 arguments非严格模式 下修改参数的值会反映到 arguments 对象中，而 严格模式 不会，因为它们是完全独立的；12345678910// 修改命名参数的值// 非严格模式：修改会反映到 arguments 中// 严格模式：修改不会反映到 arguments 中function showValue(value) &#123; value = "Foo"; alert(value); // "Foo" alert(arguments[0]); // 非严格模式："Foo" // 严格模式："Hi"&#125;showValue("Hi");7. 淘汰了 arguments.callee 和 arguments.caller1234567891011// 访问 arguments.callee// 非严格模式：没有问题// 严格模式：抛出 TypeErrorfunction factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); &#125;&#125;var result = factorial(5);8. 函数名限制不能使用 implements、interface、let、package、private、protected、public、static、yield 作为函数名；非严格模式 下可使用；9. if 内不能声明函数严格模式 下，只能在脚本的顶级和函数内部声明函数，也就是说，在 if 语句中声明函数会导致语法错误；12345678// 在 if 语句中声明函数// 非严格模式：将函数提升到 if 语句外部// 严格模式：抛出语法错误if (true) &#123; function doSomething() &#123; //... &#125;&#125;10. eval 在包含的上下文中不能再创建变量和函数严格模式 下，eval 内声明的变量只在 eval 表达式内部有效；1234567// 使用 eval() 创建变量// 非严格模式：弹出对话框显示 10// 严格模式：调用 alert(x) 时会抛出 ReferenceError function doSomething() &#123; eval("var x=10"); alert(x);&#125;12345// 严格模式：eval() 声明的变量只在 eval 表达式内部有效function doSomething() &#123; var result = eval("var x=10, y=11, x+y"); alert(result); // 21&#125;11. 禁止使用 eval 和 arguments 作为标识符，也不能修改它们的值严格模式 下禁止使用 eval 和 arguments 作为标识符，也不允许读取它们的值。以下几种方式都会抛出错误：使用 var 声明；赋予另一个值( arguments=&quot;xx&quot; 整体赋值会报错，arguments[0]=&quot;yy&quot; 单独赋值不会报错)；尝试修改包含的值，如使用 ++ (也相当于整体赋值了) ；用作函数名；用作命名的函数参数；在 try-catch 语句中用作例外名；1234567// 把 eval 和 arguments 作为变量引用// 非严格模式：不报错// 严格模式：抛出语法错误function doSomething()&#123; var eval = 10; var arguments = "Hello world!";&#125;12. 抑制this在 非严格模式 下使用 call() 和 apply() 方法时，null 和 undefined 会自动转换为 全局对象 ；而在 严格模式 下，函数的 this 的值始终是指定的值；12345678// 访问属性// 非严格模式：访问全局属性// 严格模式：抛出错误，因为 this 的值为 nullvar color = "red";function displayColor() &#123; alert(this.color);&#125;displayColor.call(null);13. 抛弃了 with 语句非严格模式 下使用 with 能够改变解析标识符的路径，严格模式 下使用 with 会导致语法错误；123456// with 的语句用法// 非严格模式：允许// 严格模式：抛出语法错误with(location) &#123; alert(href);&#125;14. 去掉了八进制字面量严格模式 下，八进制字面量已经成为无效的语法了，会抛出异常；1234// 使用八进制字面量// 非严格模式：值为8// 严格模式：抛出语法错误var value = 010;在使用 parseInt() 时，严格模式下 八进制字面量会被当作以 0 开头的十进制字面量；1234// 使用 parseInt() 解析八进制字面量// 非严格模式下：值为8// 严格模式下：值为10var value = parseInt("010");]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》总结]]></title>
    <url>%2F2019%2F06%2F12%2Fprofessional-js%2F</url>
    <content type="text"><![CDATA[终于把《JavaScript 高级程序设计》看完(假装看完，其实跳过了几章 0.0)了，颇有一些心得，总结一下。首先就是，这本书的内容，大而全。Js的各方面都有介绍，内容详细，涉及面广。其次，有些内容相对较旧了。毕竟 第三版 是2012年3月发行的，当时 ES6 还没定稿，所以这本书后面有些内容，和现在会稍有不同，主要是最后几章。接下来，是看完本书后的部分总结。心得JS加载JS会阻塞 DOM 的加载和渲染。defer ：立即加载JS，但不执行，待DOM渲染完成后再执行JS。多个 defer 按顺序执行，但实际上不一定，所以建议只有1个JS使用 defer 参数。XHTML 下需写成 defer=&quot;defer&quot; 。async ：异步加载JS(不阻塞DOM)，加载完后执行JS(此时会阻塞DOM)，执行完后继续加载/渲染DOM。不按顺序执行。XHTML 下需写成 async=&quot;async&quot; 。类型检测基本类型 ：typeof 。包括 undefined、number、boolean、string ，外加 function 。引用类型 ：instanceof 。包括 Object、Array、Date、Regexp 。检测 Object 永远返回 true ，检测 基本类型 永远返回 false 。1234567// 基本类型var str = "string";alert(typeof(str)); // string// 引用类型var person = &#123;&#125;;alert(person instanceof Object); // true垃圾收集垃圾收集主要有 标记清除 和 引用计数 两种方式，其中 标记清除 是现在的主流方式。标记清除 ：现在5大主流浏览器使用的方式。当一个变量进入一个环境(比如函数)时，将该变量标记为 进入环境 ，当该变量离开环境(比如函数)时，标记该变量为 离开环境 。垃圾收集器会给存储在内存上的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量。最后垃圾收集器销毁那些带标记的值并回收它们所占用的空间。不同浏览器垃圾收集的时间间隔不同。引用计数 ：含义是：跟踪记录每一个值被引用的次数。当一个值被一个变量引用时，该值的 引用次数 +1，又被另一个变量引用时，引用次数 继续+1，取消引用也类似。当 引用次数 为0后，当 垃圾收集器 下次运行时，就会释放这些 引用次数 为0的值所占用的内存。这个方法有个严重的 bug ，当循环引用的时候，引用次数就永远不会为0，垃圾收集器也就 永远不会回收这些循环引用的值/变量 。可以使用 variable = null 这样的方式 手动清除引用 。函数call，apply ：第一个参数是 this 的值，同时也是这个函数的环境/作用域；第二个参数是传入函数的参数；利用第一个参数，可以改变函数执行的环境/作用域，这是最常用且非常巧妙的一种用法！！；123456789101112age = 10;var obj = &#123; name: 'Jack', age: 18&#125;;var fun1 = function(num) &#123; alert(this.age + num);&#125;// 传入nullfun1.apply(null, [1]); // 非严格模式下，this为window；严格模式下，this为null，然后会报错。// 传入thisfun1.apply(this, [1]); // this为window，全局作用域，返回11// 传入objfun1.apply(obj, [1]); // this为obj对象，obj作用域，返回19arguments.callee() ：指向当前函数，一般 递归函数 中使用较多。严格模式 下不能使用。1234567891011121314151617// 阶乘函数function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num - 1); &#125;&#125;//可以改写成以下写法，减少函数的执行与函数名的耦合function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); // 此行改动 &#125;&#125;arguments.caller() ：指向调用该函数的函数，返回调用函数的源代码。严格模式 下不能使用。1234567function outer() &#123; inner();&#125;function inner() &#123; alert(arguments.callee.caller);&#125;outer(); // 返回outer函数的源代码JSONJSON类型简单值 ：包含 字符串、数值、布尔值 和 null ( undefined 会自动被忽略 )。JSON字符串 和 JS字符串 的区别：JSON字符串 必须使用双引号，JS字符串 可以使用 双引号 和 单引号 ；对象 ：JSON对象 和 JS对象 的区别：JSON对象 的属性名必须使用 双引号 ，JS对象 的属性名 可以加双引号也可以不加引号 ；JSON对象 没有声明变量；JSON对象 末尾没有 分号 ；数组 ：JSON数组 和 JS数组 的区别：JSON数组 没有声明变量；JSON数组 末尾没有 分号 ；JSON.stringify(obj, para1, para2) ：JS对象 =&gt; JSON字符串 ；para1 ：可选，用于过滤结果，可以是数组或函数；数组 ：只返回数组中的 key ；function(key, value) ：重新格式化每个 key 的值；para2 ：可选，用于指定缩进，可以是数值或字符串；数值：缩进 n 个空格，最大长度为10；字符串：缩进字符串，最大长度为10；JSON.parse(str, para1) ：JSON字符串 =&gt; JS对象 ；para1 ：可选，和 JSON.stringify 的 para1 中的 fucntion 类似，用于还原结果，是一个函数；function(key, value) ：重新格式化每个 key 的值；AjaxAjax 是一种局部刷新页面的技术，它向服务器请求数据而无需卸载页面，只局部刷新页面。原生写法123var xhr = new XMLHttpRequest();xhr.open(type, url, isAsync);xhr.send(data);说明：type ：post 、get 等；url ：请求的 url ，get 请求时查询字符串参数必须使用 encodeURIComponent() 进行编码；isAsync ：是否异步。jQuery 默认为 true ；data ：一定要填，为空的话写 null ；可以使用表单形式给服务器传数据(结果是键值对，而不是string字符串)，使用方法如下：123456789101112// 初始化// ...// 方法1var form = document.getElementById("user-info");var data = new FormData(form);// 方法2var data = new FormData();data.append("key1", "value1");data.append("key2", "value2");// 发送给服务器xhr.send(data);更多信息 ：Page 575；HTTP头信息 ：可以自定义信息在头部，供服务器读取；超时设定 ：xhr.timeout 、xhr.ontimeout=function(){} ；进度事件 ：load 、progress ；跨域介绍CORS(Cross-Origin-Resource Sharing) 定义了跨域时，浏览器与服务器该如何通信。CORS 的基本思路浏览器 =&gt; 服务器 的 请求头 中添加：Origin: url ；服务器 =&gt; 浏览器 的 响应头 中添加： Access-Control-Allow-Origin: url ；这2个 url 必须一致；IE8 的跨域使用 XDR(XDomainRequest) 对象来创建实例(替代 XMLHttpRequest 对象)；123var xdr = new XDomainRequest();xdr.open(type, url, isAsync);xdr.send(data);其他主流浏览器的跨域原生支持 ：直接使用 XMLHttpRequest 对象创建实例即可；其他跨域技术图像Ping ：单向，浏览器 =&gt; 服务器 ；JSONP ：双向，把 url 添加到 &lt;script&gt; 标签中，然后 &lt;script&gt; 标签添加到 document.body 内；Comet ：长轮询 和 流；服务器发送事件 ：SSE ；WebSocket用于在一个单独的持久连接上提供 全双工、双向通信 。原生写法123456789var socket = new WebSocket(url);socket.send(data);socket.onmessage = function(event) &#123; var data = event.data;&#125;;// 其他3个事件socket.onopen = function()&#123;&#125;;socket.onerror = function()&#123;&#125;;socket.onclose = function()&#123;&#125;;说明url ：传输协议为 ws:// 和 wss:// ，分别对应 未加密 和 加密 的协议；send ：data 只能是 字符串 ;onmessage ：服务器 返回的数据存放在 event.data 中；优缺点优点 ：能够双向通信，服务器 能主动推送数据给 浏览器 ；传输数据小，占用资源少，速度快。因为相比较 http/https 的传输协议，ws/wss 的请求头更小，所以每次传输数据，“无效”的请求头数据会更少，对于高频率的请求效果更明显；缺点 ：h5 新增的功能，对于某些旧浏览器并不支持；需要使用不同的 web服务器(传输协议为 ws/wss ) ；高级技巧高级函数安全的类型检测instanceof 检测时，必须是在同一个全局作用域下才有效(比如一个页面包含多个frame时，在 非构造函数页面 检测会返回false)；利用 原生XX 的构造函数名与全局作用域无关，因此使用 toString() 就能够保证返回一致的值，所以可以创建以下函数；123456789101112// 检测数组function isArray(value) &#123; return Object.prototype.toString.call(value) == "[object Array]";&#125;// 检测函数function isFunction(value) &#123; return Object.prototype.toString.call(value) == "[object Function]";&#125;// 检测正则表达式function isRegExp(value) &#123; return Object.prototype.toString.call(value) == "[object RegExp]";&#125;作用域安全的构造函数当使用构造函数创建对象时，忘记使用 new 的情况下；123456789function Person(name, age, job) &#123; if (this instanceof Person) &#123; this.name = name; this.age = age; this.job = job &#125; else &#123; return new Person(name, age, job); &#125;&#125;原理：使用 new 的情况下，this 指向的是 new 出来的新对象；未使用 new 的情况下，this 指向的是 全局对象window ；惰性载入函数在某些 if 判断的语句中，如果第一次怎样，后面每次都会这样，针对这种情况，可以使用 惰性载入函数 ，即 if里重写原方法，这样后面执行是就不用判断了；惰性载入函数 有两种写法：第一种是：函数被调用时再处理函数：第二种是：声明函数时就指定适当的函数：1234567891011// 原函数function createXHR() &#123; if (typeof XMLHttpRequest != "undefined") &#123; return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != "undefined") &#123; //... return new ActiveXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error("No XHR object available."); &#125;&#125;1234567891011121314151617// 第一种：函数被调用时再处理函数function createXHR() &#123; if (typeof XMLHttpRequest != "undefined") &#123; createXHR = function()&#123; // 改变1 return new XMLHttpRequest(); &#125; &#125; else if (typeof ActiveXObject != "undefined") &#123; createXHR = function() &#123; // 改变2 //... return new ActiveXObject(arguments.callee.activeXString); &#125; &#125; else &#123; createXHR = function() &#123; // 改变3 throw new Error("No XHR object available.") &#125; &#125;&#125;1234567891011121314151617// 第二种：声明函数时就指定适当的函数var createXHR = (function() &#123; if (typeof XMLHttpRequest != "undefined") &#123; return function() &#123; // 改变1 return new XMLHttpRequest(); &#125; &#125; else if (typeof ActiveXObject != "undefined") &#123; return function() &#123; // 改变2 // ... return new ActiveXObject(arguments.callee.activeXString); &#125; &#125; else &#123; return function() &#123; // 改变3 throw new Error("No XHR object available.") &#125; &#125;&#125;)(); // 改变4函数绑定函数绑定 要创建一个函数，可以在特定的 this 环境中以指定参数调用另一个函数；来看下面这个例子：12345678910111213var handler = &#123; message: "Event handler", handlerClick: function() &#123; alert(this.message); &#125;&#125;;var btn = document.getElementById("my-btn");// 返回undefinedEventUtil.addHandler(btn, "click", handler.handlerClick);// 返回Event handler, // 传入作为this值的对象，和 call，apply 类似EventUtil.addHandler(btn, "click", handler.handlerClick.bind(handler));函数柯里化用于创建已经设置好了一个或多个参数的函数；函数柯里化 的基本方法和 函数绑定 是一样的，都是使用一个闭包返回一个函数；两者的区别在于：当函数被调用时，返回的函数还需要设置一些传入的参数；来看下面的例子：123456789// 函数柯里化 定义函数function curry(fn) &#123; var args = Array.prototype.slice.call(arguments, 1); return function() &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); &#125;&#125;1234567// 函数柯里化 使用方法1// 超出参数自动忽略function add(num1, num2) &#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5);alert(curriedAdd(3)); // 81234567// 函数柯里化 使用方法2// 超出参数自动忽略function add(num1, num2) &#123; return num1 + num2;&#125;var curriedAdd = curry(add, 5, 13, 2);alert(curriedAdd()); // 18防篡改对象注意：一旦把对象定义为防篡改，就不可撤销了 。不可扩展对象不能添加属性和方法，可删除和修改；使用 Object.preventExtensions(obj) 把 obj对象 修改为 不可扩展对象 ；密封的对象不能添加和删除属性和方法，但可修改；使用 Object.seal(obj) 把 obj对象 修改为 密封的对象 ；冻结的对象既不可扩展，又是冻结的。即不可新增、修改、删除属性和方法；使用 Object.freeze(obj) 把 obj对象 修改为 冻结的对象 ；高级定时器setTimeout 和 setInterval() 并不是 过xx毫秒后执行函数 ，而是 过xx毫秒后把函数代码添加到代码队列，在浏览器空闲时，将按队列顺序依次执行队列中的代码 。重复的定时器使用 setInterval() 时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中，这确保了队列中的最小时间间隔为指定间隔；当这种 重复定时器 有两个问题：(1)某些间隔会被跳过；(2)多个定时器的代码执行之间的间隔可能会比预期的小；为了解决这种问题，可以使用如下模式的 链式setTimeout()调用 ；1234setTimeout(function()&#123; // 处理中 setTimeout(arguments.callee, interval);&#125;, interval);Yielding Processos当某个循环占用了大量时间，如果该循环满足 1无需同步完成，2无需按顺序完成 ，则可使用一种叫做 数组分块 的技术，小块小块的处理数组，通常每次一小块；基本思路：为要处理的数组创建一个队列，然后使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器；看下面这个例子：1234567891011// 思路setTimeout(function()&#123; // 取出下一个项目并处理 var item = array.shift(); process(item); //若还有条目，再设置另一个定时器 if (array.length &gt; 0) &#123; setTimeout(arguments.callee, 100); &#125;&#125;, 100)12345678910111213141516171819// 实际例子function chunk(array, process, context) &#123; setTimeout(function() &#123; var item = array.shift(); process.call(context, item); if (array.length &gt; 0) &#123; setTimeout(arguments.callee, 100); &#125; &#125;, 100);&#125;var data = [12,123,23,234,1234,323,444,555,666,777];function printValue(item) &#123; var div = document.getElementById("myDiv"); div.innerHTML += item + "&lt;br&gt;";&#125;chunk(data, printValue);函数节流浏览器中某些操作(比如DOM)非常耗资源，高频率的进行这种操作可能会让浏览器崩溃。为了解决这个问题，可以使用定时器对该函数进行 节流 ；函数节流 背后的思路是：某些代码不可以在没有间断的情况下连续重复执行。第一次调用函数时，会创建一个定时器，在指定的时间间隔后再执行函数；第二次调用时，会先清除前一次的定时器，并设置另外一个，然后重复前面的步骤；来看下面的例子：1234567// 思路function throttle(method, context) &#123; clearTimeout(method.tId); var method.tId = setTimeout(function() &#123; method.call(context); &#125;, 100)&#125;12345// 未节流前写法，高频率的更新可能导致浏览器崩溃window.onresize = function() &#123; var div = document.getElementById("myDiv"); div.style.height = div.offsetWidth + "px";&#125;;123456789// 节流写法function resizeDiv() &#123; var div = document.getElementById("myDiv"); div.style.height = div.offsetWidth + "px";&#125;window.onresize = function() &#123; throttle(resizeDiv);&#125;自定义事件事件 是一种叫做 观察者 的设计模式，这是一种创建松散耦合代码的技术；观察者模式 由 主体 和 观察者 两部分组成；主体 ：发布事件；观察者 ：订阅事件，观察主体；Cookie服务器 生成并返回给 浏览器 的；绑定在特定域名下，只在绑定的域名下有效；(针对域名) 只要有的话，浏览器每次发数据给 服务器 ，一定会带上已经存在的 cookie ；未设定有效期的 cookie ，浏览器关闭后即失效，设定有效期的 cookie，手动删除或到期前，一直有效；最佳实践优化DOM在 JavaScript 各个方面中，DOM 毫无疑问是最慢的一部分。当往页面添加多个 &lt;li&gt; 元素时，每添加一次都要进行一次 现场更新，即页面要进行一次 重排重绘 ，性能损失非常大。最小化更新现场使用 文档片段 来构建DOM结构，接着将其添加到 List 元素中，这样只会进行一次 现场更新 ；12345678910var list = document.getElementById("myList"), fragment = document.createDocumentFragment(), item, i;for (i=0;i&lt;10;i++) &#123; item = document.createElement("li"); fragment.appendChild(item); item.appendChild(document.createTextNode("Item" + i));&#125;list.appendChild(fragment);使用 innerHTML创建 DOM 节点到另一种方法(前一种是 createElement 、appendChild 之类的)；对于小的 DOM 节点更改，两种方法效率差不多，然而对于大的 DOM 节点的更改，innerHTML 要比前一种快的多，因为只进行一次 现场更新 ；1234567var list = document.getElementById("myList"), html = "", i;for (i=0;i&lt;10;i++) &#123; html += "&lt;li&gt;Item" + i + "&lt;/li&gt;";&#125;list.innerHTML = html;使用事件代理利用 事件冒泡 ，在文档级别附加事件处理程序，这样可以处理整个页面的事件；注意 HTMLCollection任何时候要访问 HTMLCollection ，不管它是一个属性还是一个方法，都是在文档上进行一个查询，这个查询开销很大；最小化访问 HTMLCollection 的次数可以极大的改进脚本的性能；优化 HTMLCollection 最重要的地方就是循环了；以下情况会返回 HTMLCollection 集合：进行了对 getElementsByTagName 的调用 ；获取了元素的 ChildNodes 属性 ；获取了元素的 attributes 属性 ；访问了特殊的集合，比如 document.forms、document.images 等 ；来看下面的例子：1234567891011121314151617// 优化前var images = document.getElementsByTagName("img"), i, len;for(i=0, len=images.length;i&lt;len;i++) &#123; //...&#125;// 优化后var images = document.getElementsByTagName("img"), image, i, len;for(i=0, len=images.length;i&lt;len;i++) &#123; image = images[i]; //...&#125;部署压缩 ：压缩分两部分，即 文件压缩 和 HTTP压缩 。文件压缩 ：把开发环境的文件( js、css 等)压缩，然后部署到服务器上；删除额外的空白，包括换行；删除所有注释；缩短变量名；HTTP压缩 ：服务器对传输给浏览器的代码进行压缩(服务器要进行配置)；浏览器对接收的资源进行解压缩，目前五大 Web浏览器都支持解压缩；；可以节省传输的字节，减少带宽消耗，加快响应速度；原理 ：一个指定了文件 使用了给定格式 进行了压缩的HTTP头 包含在了服务器响应中。接着浏览器会查看该 HTTP头确定文件是否已被压缩，然后使用合适的格式进行解压缩；新APIrequestAnimationFrame()早期动画循环；Page Visiblity APIdocument.hidden ：查看页面是否隐藏的布尔值。页面隐藏包括在后台标签页中或最小化浏览器；document.visibilityState ：表示下列4个可能状态的值：页面在后台标签中或浏览器最小化；页面在前台标签页中；实际的标签页已经隐藏，但用户可以看到页面的预览(比如win7鼠标移到任务栏的图标上看到的预览)；页面在屏幕外执行预渲染处理；visibilitychange 事件：文档从可见变为不可见，或从不可见变为可见时触发；Geolocation API地理定位 API；navigator.geolocation 对象；getCurrentPosition ：获取当前位置；watchPosition ：跟踪用户位置，与定时调用 getCurrentPosition 效果一样；clearWatch ：取消跟踪用户位置；File API能够在浏览器端读取本地文件的信息(文件名称，类型，大小，修改时间，文件内容等)；使用 &lt;input type=&quot;file&quot;&gt; 元素，返回对象的 files 属性；FileReader 类型var reader = new FileReader() ；readAsText(file, encoding) ：以纯文本形式读取文件，数据保存在 result 属性中；readAsDataURL(file) ：读取文件并将文件以 URI 的形式保存在 result 属性中；对象 URL引用保存在 File 或 Blob 中数据的 URL；window.URL.createObjectURL(file) ：获取 file 的URL；Web 计时window.performance ：获取页面的所有度量信息(即时间相关信息)；Web WorkersJavaScript 是单线程的；让 JavaScript 在后台运行，类似开了一个后台线程；来看下面的例子：1234567891011121314var worker = new Worker("stufftodo.js");// 这行代码会让浏览器下载js，但只有 worker接收到消息才会执行js代码// 使用 postMessage() 给 workder发送消息，可以是字符串或对象worker.postMessage("start! ");// worker返回到数据保存在 event.data 中worker.onmessage = function(event) &#123; var data = event.data; //...&#125;;worker.onerror = function(event) &#123; &#125;;// 立即停止 workder 到工作worker.terminate();跳过的章节其中有几章没看跳过了，有些是已经熟悉的，有些是优先级不高暂时跳过了，以后有时间了再补上吧～跳过的章节有：第8章：BOM；第9章：客户端检测；第10～12章：DOM；第13章：事件；第14章：表单；第15章：Canvas；第18章：JS与XML；第19章：E4X；严格模式有关 严格模式 与 非严格模式 的区别，请看下篇文章。点我查看]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 中的Flex]]></title>
    <url>%2F2019%2F05%2F31%2Fflex%2F</url>
    <content type="text"><![CDATA[CSS3 引入了一种新的布局模式————弹性盒子。引入弹性盒子的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。简介弹性盒子由 弹性容器(Flex container) 和 弹性子元素(Flex item) 组成。弹性容器 通过设置 display 的值为 flex 或 flex-inline ，将其定义为 弹性容器 。弹性容器 内包含一个或多个 弹性子元素 。弹性容器 外和 弹性子元素 内都是正常渲染，弹性盒子 只定义了 弹性子元素 如何在 弹性容器 内的布局。Flex 即为 弹性布局。设置为 Flex 布局之后，子元素 的 float、clear 和 vertical-align 属性将失效。接下来，介绍 Flex 常用的几个属性。常用属性flex-directionflex-direction ：弹性子元素 在 弹性容器 内 水平方向 上的排列规则。注意，这很重要：flex-direction 方向不同( row ，column )，会导致其他6个 flex 属性( flex-wrap，felx-flow，justify-content，align-content，align-items，align-self )的方向也不同！！后面6个 flex 属性的例子中，flex-direction 都为 row 。如果 flex-direction 改成 column ，会导致方向与现在的例子相反。即 水平xx 的都会变成 垂直xx ，而 垂直xx 的会变成 水平xx 。主要有以下几个值：row、row-reverse、column、column-reverse、initial、inherit 。row默认值 ；水平方向，从左往右正常排列。row-reverse水平方向，从右往左排列。column垂直方向，从上往下排列。column-reverse垂直方向，从下往上排列。initial设置改属性为它的默认值。inherit从父元素继承该属性。flex-wrapflex-wrap ：规定 弹性子元素 是一行还是多行显示在 弹性盒子 内。即 弹性子元素 是否换行。主要有以下几个值：nowrap、wrap、wrap-reverse、initial、inherit 。nowrap默认值 ； 弹性子元素 不换行，宽度会改变(压缩)。wrap弹性子元素 换行，宽度不会改变。wrap-reverse弹性子元素 换行，宽度不会改变，且从右往左排序。initial设置该属性为它的默认值。inherit从父元素继承该属性。flex-flowflex-flow ：flex-direction 和 flex-wrap 的组合，第一个参数为 flex-direction ，第二个参数为 flex-wrap 。row-reverse wrap反向排序，且换行。justify-contentjustify-content ：弹性子元素 关于 弹性盒子 垂直轴，在水平方向上的分布规则。主要有以下几个值：flex-start、flex-end、center、space-between、space-around、initial、inherit 。flex-start默认值 ；不拆分，紧贴 弹性容器 的左边框。flex-end不拆分，紧贴 弹性容器 的右边框。center不拆分，在 弹性容器 内居中显示。space-between拆分，分别紧贴 弹性容器 的左、右边框， 弹性子元素 之间由 空白 分隔。space-around拆分，每个 弹性子元素 由宽度相同的 空白 围绕。所以 弹性子元素到边框 的距离是 弹性子元素到弹性子元素 距离到一半。initial设置该属性为它的默认值。inherit从父元素继承该属性。align-contentalign-content ：弹性子元素 关于 弹性盒子 水平轴，在垂直方向上的分布规则。提示： 使用该参数时必须同时使用 flex-wrap: wrap 或 flex-flow: xxx wrap (wrap-reverse 也可)。主要有以下几个值：stretch、flex-start、flex-end、center、space-between、space-around、initial、inherit 。stretch ：默认值 ；拆分，弹性子元素 被拉伸以适应 弹性容器 。flex-start不拆分，弹性子元素 紧贴 弹性容器 的上边框。flex-end不拆分，弹性子元素 紧贴 弹性容器 的下边框。center不拆分，在 弹性容器 内居中显示。space-between拆分，分别紧贴 弹性容器 的上、下边框，弹性子元素 之间由 空白 分隔。space-around拆分，每个 弹性子元素 由宽度相同的 空白 围绕。所以 弹性子元素到边框 的距离是 弹性子元素到弹性子元素 距离到一半。initial设置该属性为它的默认值。inherit从父元素继承该属性。align-itemsalign-items ：设置 弹性容器 内的 所有 的 弹性子元素 的对齐方式。主要有以下几个值：stretch、flex-start、flex-end、center、baseline、initial、inheritstretch默认值 ；拉伸 弹性子元素 以适应 弹性容器 。flex-start弹性子元素 向上对齐 弹性容器 。flex-end弹性子元素 向下对齐 弹性容器 。center弹性子元素 居中对齐 弹性容器 。baseline弹性子元素 对齐 弹性容器 的基线(基本等效于 flex-start )。initial设置该属性为它的默认值。inherit从父元素继承该属性。align-selfalign-items ：设置 弹性容器 内的 单个 弹性子元素 的对齐方式。主要有以下几个值：auto、stretch、flex-start、flex-end、center、baseline、initial、inherit 。auto默认值 ；继承它的父容器 (弹性容器) 的 align-items 属性，如果没有父容器则该值为 stretch 。stretch拉伸 弹性子元素 以适应 弹性容器 。flex-start弹性子元素 向上对齐 弹性容器 。flex-end弹性子元素 向下对齐 弹性容器 。center弹性子元素 居中对齐 弹性容器 。baseline弹性子元素 对齐 弹性容器 的基线(基本等效于 flex-start )。initial设置该属性为它的默认值。inherit从父元素继承该属性。参考链接css display:flex 属性CSS flex 属性CSS3 弹性盒子(Flex Box)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入url之后...]]></title>
    <url>%2F2019%2F05%2F25%2Fafter-input-url%2F</url>
    <content type="text"><![CDATA[最近找工作，发现面试官都会问一个问题：在浏览器输入url之后，会发生什么？那么，在浏览器输入url之后，到底会发生什么呢？接下来，我们一起学习一下 ~主要过程当我们在浏览器地址栏输入url之后，主要会经过下面几个步骤：域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后，发起http请求 –&gt; 服务器响应http请求，发送html代码给浏览器 –&gt; (默认)服务器发送html代码后，发起4次挥手，断开TCP请求 –&gt; 浏览器渲染页面1. 域名解析域名解析，又叫 DNS解析。用于把地址栏的URL解析成服务器的IP地址，进而访问服务器。域名解析按优先级，会有以下几种情况：查询浏览器缓存 ：浏览器会缓存之前拿到的DNS 2-30分钟时间，如果没有找到，继续下一种情况；查询系统缓存 ：检查 hosts 文件，这个文件保存了一些以前访问过的网站的域名和IP的数据。它就像一个本地的数据库，如果找到就可以直接获取目标主机的IP地址了。如果没找到，继续下一种情况；查询路由器缓存 ：路由器有自己的DNS缓存，可能包含了需要查询的内容。如果没有，继续下一种情况；查询ISP DNS 缓存 ：ISP服务商的DNS缓存（本地服务器缓存），那里可能有相关的内容。如果还没有，继续下一种情况；递归查询 ：从 根域名服务器 –&gt; 顶级域名服务器 –&gt; 权限域名服务器 –&gt; 得到服务器IP ；举个(ISP+递归查询)例子，浏览器发起一个DNS的系统调用，首先会先向本地配置的首选DNS服务器(一般是电信运营商提供的，也可以使用像Google提供的DNS服务器)发起域名解析请求。运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则由运营商的DNS代我们的浏览器发起迭代的DNS解析请求。它首先会找一个 根域的DNS的IP地址 ，找到 根域 的地址后，就会向其发起请求(请问 www.linux178.com 这个域名的IP地址是多少啊？ )，根域 发现这是一个 顶级域com域 的一个域名，就告诉运营商的DNS我不知道这个域名的IP地址，但我知道 com域 的IP地址，你可以去问它，于是运营商的DNS就得到了 com域 的IP地址，又向 com域 的DNS地址发起了请求(请问 www.linux178.com 这个域名的IP地址是多少啊？)，com域 这台服务器告诉运营商DNS，我不知道 www.linux178.com 这个域名的IP地址，但我知道 linxu178.com 这个域的IP地址，你可以去问它，于是运营商的DNS又向 linux178.com 这个域的DNS地址(这个一般就是由域名注册商提供的，像万网、新网等)发送请求(请问 www.linux178.com 这个域名的IP地址是多少啊？)，这个时候 linux178.com域 的DNS服务器一查，诶，果然在我这里，于是就把找到的结果返回给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了 www.linux178.com 这个域名的IP地址了，之后再返回给浏览器，浏览器就得到要访问域名的IP地址了。2. TCP的三次握手第一次握手 ：Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN=1 表示这是一个请求连接或连接接受报文，同时表示这个接受报不能携带数据，seq=x 表示Client自己的初始序号(seq=0 就代表这是第0号包)，这时候Client进入 syn_sent ，表示客户端等待服务器的响应；第二次握手 ：Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的 SYN 和 ACK 都置1，ack=x+1 表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到(ack=1 其实就是 ack=0+1，也就是期望客户端的第1个包)，seq=y 表示Server自己的初始序号(seq=0 就代表这是服务器这边发出的第0号包)。这时服务器进入 syn_rcvd 状态，表示服务器已经收到Client的连接请求，等待Client的确认；第三次握手 ：Client收到确认后还需要再次发送确认，同时携带要发送给Server的数据。ACK=1 表示确认号 ack=y+1 有效(代表收到服务器的第1个包)，Client自己的序号seq=x+1(表示这就是我的第一个包，相对于第0个包来说的)，一旦收到Client的确认后，这个TCP连接就进入了 Established 状态，就可以发起http请求了。为什么要3次握手为了防止已失效的连接请求报文突然又传送到了服务器，进而产生错误。举个例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到达server。这本来是一个早已失效的报文段，但server收到此报文段后，误认为这是client再出发出的一个新的连接请求。于是就像client发出确认报文段，同意建立连接。假设不采用 三次握手 ，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的连接已经建立了，并一直在等待client发来数据。这样，server的很多资源就白白浪费了。采用 三次握手 的方法就可以防止上述现象的发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。3. 传输数据HTTP请求报文一个HTTP请求报文由 请求行(request line) ，请求头部(header) ，空行 ，请求数据 4个部分组成，下图给出了请求报文的一般格式。请求行请求行分为三个部分：请求方法 ，请求地址 和 协议版本 。请求方法HTTP/1.1 定义的请求方法有8中：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE 。最常用的两种是 GET 和 POST ，如果是 RESTful 接口的话一般会用到 GET、POST、DELETE、PUT 。请求地址URL：统一资源定位符，是一种资源位置的抽象唯一识别方法。组成如下(端口和路径有时可以省略) ：GET 请求时，有时会带参数。协议版本协议版本的格式为：HTTP/主版本号.次版本号 ，常用的有 HTTP/1.0 和 HTTP/1.1 。请求头部请求头部为请求报文添加了一些附加信息，由 名/值 对组成，每行一对，名和值之间用冒号分隔。常见请求头如下：请求头部的最后会有一个 空行 ，表示请求头部结束，接下来为请求数据。这一行非常重要，必不可少。请求数据可选部分，比如 GET 请求就没有请求数据。下面是一个 POST 方法的请求报文：123456789101112POST /index.php HTTP/1.1 //请求行Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2 //请求头Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveReferer: http://localhost/Content-Length：25Content-Type：application/x-www-form-urlencoded //空行username=aa&amp;password=1234 //请求数据HTTP响应报文HTTP响应报文主要由 状态行 ，响应头部 ，空行 和 响应数据 4个部分组成。下图给出了响应报文的一般格式。状态行由3部分组成，分别为：协议版本 ，状态码 ，状态码描述 。其中 协议版本 和请求报文一致，状态码描述 是对状态码的简单描述，所以这里只介绍 状态码 。状态码状态码 为3位数字。1xx ：指示信息——表示请求已接收，继续处理。2xx ：成功——表示请求已被成功接收、理解、接受。3xx ：重定向——表示要完成请求必须进行进一步的操作。4xx ：客户端错误——请求有语法错误或请求无法实现。5xx ：服务器端错误——服务器未能实现合法的请求。下面列举几个常见的：响应头部与 请求头部 类似，为响应报文添加一些附加的信息。常见的 响应头部 如下：响应数据用于存放需要返回给客户端的数据信息。下面是一个响应报文的实例：12345678910111213141516171819202122HTTP/1.1 200 OK //状态行Date: Sun, 17 Mar 2013 08:12:54 GMT //响应头部Server: Apache/2.2.8 (Win32) PHP/5.2.5X-Powered-By: PHP/5.2.5Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheContent-Length: 4393Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/html; charset=utf-8 //空行&lt;html&gt; 响应数据&lt;head&gt;&lt;title&gt;HTTP响应示例&lt;title&gt;&lt;/head&gt;&lt;body&gt;Hello HTTP!&lt;/body&gt;&lt;/html&gt;4. TCP的四次挥手默认情况下的TCP连接，在服务器发送一次html数据给浏览器后，服务器就会执行 四次挥手 以 断开TCP连接 ，除了下面这种情况：持久连接 ：只要任意一端没有明确的提出断开连接，则保持TCP连接状态。在 请求首部字段 中设置 Connection:keep-alive 即表示使用了持久连接。注意 ：主机1可以是 客户端，也可以是 服务器端 ；默认情况下，主机1是 客户端，即 客户端主动断开连接 的情况 ；若 服务器端 主动断开连接，则主机1是 服务器端 ；过程描述 ：主机1 进程发出连接释放报文，并停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u(等于前面已经传送过来的数据的最后一个字节的序号加1)，此时，主机1 进入 FIN-WAIT-1(终止等待1) 状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。主机2 收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并带上自己的序列号seq=v，此时，主机2就进入了 CLOSE-WAIT(关闭等待) 状态。主机2通知高层的应用程序，主机1 向 主机2 的方向就释放了，这时候处于半关闭状态，即 主机1 已经没有数据要发送了，但是 主机2 若发送数据，主机1 仍然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。主机1 收到 主机2 的确认请求后，此时，主机1 就进入 FIN-WAIT-2(终止等待2) 状态，等待 主机2 发送连接释放报文(在这之前还需要接受 主机2 发送的最后的数据)。主机2 将最后的数据发送完毕后，就向 主机1 发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，主机2 很可能又发送了一些数据，假定此时的序列号为seq=w，此时，主机2 就进入了 LAST-ACK(最后确认) 状态，等待 主机1 的确认。主机1 收到 主机2 的连接释放报文后了，比如发出确认，ACK=1，ack=w+1，而自己的序列号seq=u+1，此时，主机1 就进入了 TIME-WAIT(时间等待) 状态。注意此时TCP链接还没有释放，必须经过 2MSL(最长报文段寿命) 的时间后，当 主机1 撤销相应的TCB后，才进入 CLOSED 状态。主机2 只要接收到了 主机1 发出的确认，就立即进入 CLOSED 状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，主机2 结束TCP连接的时间要比 主机1 早一些。为什么要四次挥手因为三次握手时只是建立一个连接，之后才传递数据，在握手时是没有数据传输的，所以3次即可。而挥手时，主机1 停止向 主机2 传输数据后，主机2 会立刻响应 主机1，先回一个ACK报文，告诉 主机1，”你发的FIN报文我收到了，但只有等我 主机2 的所有报文都发送完毕后，我才能发送FIN报文”，所以挥手的时候 主机2 要分两步，所以挥手需要四次。为什么要等待 2MSL因为网络可能不稳定，最后一个 ACK报文有可能会丢失，所以，TIME-WAIT 状态就是用来重发可能丢失的 ACK报文(第四步的报文)。在四次挥手的过程中，主机2 在 LAST-ACK(最后确认) 状态时，如果没接收到了 主机1 发来的 ACK报文，则不断发送FIN片段。所以 主机1 不能立即关闭，它必须确认 主机2 接收到了该 ACK之后，才关闭连接。所以，主机1 会设置一个计时器，等待 2MSL的时间，如果再次收到FIN，说明之前发送的ACK没有传到 主机2，于是会重新发一个ACK给 主机2；如果等待 2MSL后没有收到FIN，说明 主机2 已收到ACK且已关闭，于是 主机1 也关闭，TCP连接结束。5. 渲染HTML页面客户端拿到服务器传输过来的文件后，找到 HTML 和 MIME 文件，通过 MIME 文件，浏览器知道要用页面渲染引擎来处理 HTML 文件。页面渲染主要有以下几个步骤：1. 解析html源码，创建一个DOM树在 DOM 树中，每一个 HTML 标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。2. 解析CSS代码，计算出最终的样式数据，形成css对象模型CSSOM首先会忽略非法的CSS代码，然后按 浏览器默认设置——用户设置——外链样式——内联样式——style样式 的顺序进行渲染。3. 利用DOM和CSSOM构建一个渲染树（rendering tree）渲染树和 DOM 树有点像，但是是有区别的。DOM 树完全和 HTML标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。而且一大段文本中的每一行在渲染树中都是一个独立的节点。渲染树中的每一个节点都存储有对应的css属性。4. 浏览器根据渲染树，直接把页面绘制到屏幕上注意点JS和图片会阻塞 DOM 的加载和渲染。CSS不会阻塞 DOM 的加载，但会阻塞 DOM 的渲染(即浏览器控制台可以打印 DOM 节点了，但页面还是空白，没有渲染)。CSS会阻塞JS的加载和执行。加载JS时，添加 defer 参数，脚本会立即下载但不执行，在 DOM 加载完成后再执行。多个 defer 的脚本会按顺序执行。加载JS时，添加 async参数，脚本会异步加载再执行，执行的时候还是会阻塞 DOM 的加载。多个 async 的脚本不会按顺序执行。实际情况下，有时候多个 defer 时加载完后不一定会按顺序执行，所以建议，尽量合并成一个JS再使用 defer。关于 defer 和 async ，可以查看下图：参考链接1. 一次完整的HTTP请求过程2. 在浏览器输入URL并按回车后都发生了什么?3. 一次完整的HTTP请求过程4. 服务端主动终止连接的情况分析5. TCP的三次握手和四次挥手理解及面试题（很全面）6. defer和async的区别]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈浏览器内核]]></title>
    <url>%2F2019%2F05%2F23%2Fbrowser-kernel%2F</url>
    <content type="text"><![CDATA[内核简介一个完整的浏览器包含浏览器内核和浏览器外壳(shell)，浏览器核心––––内核分为两部分：渲染引擎 和 js引擎 。由于js引擎越来越独立，所以现在说的浏览器内核一般指 渲染引擎 。渲染引擎 ：解析DOM文档和CSS规则并将内容和样式显示到浏览器中。也叫 排版引擎 ，我们常说的浏览器内核主要指的就是 渲染引擎 。js引擎 ：解析和执行JS脚本的模块，如 V8引擎，JavaScriptCore 等。5 大主流浏览器(按时间顺序)IE 浏览器IE 是微软其下的浏览器，IE4~IE11 使用的都是 Trident 内核。Windows10 发布后，IE 将其内置浏览器命名为 Edge，使用新内核 EdgeHTML 。IE 从版本11开始，初步支持 WebGL 技术。IE8 的js引擎是 jscript ，IE9开始使用 Chakra ，这两个版本差别很大，Chakra 无论是速度还是标准化方面都很出色。Edge的JS引擎是 Chakra。Opera 浏览器Opera 是挪威 Opera Software ASA 公司其下的浏览器。1995年，Opera 公司发布第一版 Opera 浏览器，并使用 Presto 内核。2016年奇虎360和昆仑万维收购了 Opera 浏览器，并改用当时 Google 开源的 webkit 内核。之后 Opera 又跟随 Google 将浏览器内核改为 Blink 。Safari 浏览器Safari 是 Apple 公司自研的浏览器，主要用于 Apple 自身的产品。第二次浏览器大战也是从苹果公司发布 Safari 开始的。2003年，苹果公司在苹果手机上开发 Safari 浏览器，利用自己得天独厚的手机市场份额使 Safari 浏览器迅速成为世界主流浏览器。Safari 是最早使用 webkit 内核的浏览器，后来升级为 webkit2 内核，也是现在苹果默认的浏览器。Safari 的JS引擎是 JavaScriptCore 。Firefox 浏览器Firefox 是 Mozilla 公司旗下的浏览器，也就是 网景 公司后来的浏览器。网景被收购后，网景人员创办了 Mozilla 基金会，这是一个非营利性的组织，他们在2004年推出自己的浏览器 Firefox。Firefox 采用 Gecko 内核。Firefox 的JS引擎是 SpiderMonkey 。Gecko 是一个开源的项目，代码完全公开，因此受到很多人的青睐。Chrome 浏览器Chrome 是 Google 公司的浏览器。Chrome 最开始使用 webkit 分支出的 Chromium 内核，后来升级为 Blink 内核。Chrome 的JS引擎是 V8 。浏览器与JS引擎5 大内核Trident 内核也就是俗称的 IE内核 。Trident 内核迭代列表使用该内核的浏览器有：IE浏览器，多核浏览器。Presto(Opera前内核)(已废弃)Opera12.17及更早版本曾使用此内核，现已停止开发并废弃。Opera在2013年2月宣布放弃 Prosto，转而跟随 Chrome 使用 webkit 的分支 Chromium 引擎作为其核心。在 Chrome 与 2013年推出 Blink 核心后，Opera 也紧跟随其脚步使用 Blink 核心。Webkit 内核苹果公司研发的内核，后来升级为 webkit2。webkit内核包括：WebCore渲染引擎 和 JavaScriptCore解析引擎，均是从 KDE 的 KHTML 和 KJS 衍生而来的。2008年，Google 发布了 Chrome 浏览器，浏览器使用的内核叫做 Chromium 。Chromium fork 自开源引擎 Webkit ，Google 还研发了自己的JS引擎，即 V8引擎 ，极大的提高了 JavaScript 的运行速度。使用该内核的浏览器有：Safari，Android 默认浏览器，多核浏览器。Gecko 内核Netscape6 开始采用的内核，后来的 Mozilla Firefox 也采用了相同的内核。使用该内核的浏览器有：Mozilla Firefox，Mozilla SeaMonkey，Flock(早期版本)，K-Meleon 。Blink 内核2013 年 4 月 3 日，谷歌在 Chromium Blog 上发表 博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 是一个由 Google 和 Opera Software 开发的浏览器 渲染引擎，Google 计划将这个渲染引擎作为 Chromium 计划的一部分。这一渲染引擎是开源引擎 WebKit 中WebCore 组件的一个分支，并且在 Chrome（28及往后版本）、Opera（15及往后版本）和 Yandex 浏览器中使用此外，Mozilla 与三星也达成合作协议开发”下一代”浏览器渲染引擎Servo。使用该内核的浏览器：Chrome，Opera，多核浏览器。补充：什么是 Chromium 计划Chromium 是 Google 为发展自家的浏览器 Google Chrome（以下简称Chrome）而开启的计划，所以 Chromium 相当于 Chrome 的工程版或称实验版（尽管Chrome自身也有β版阶段），新功能会率先在 Chromium 上实现，待验证后才会应用在 Chrome 上，故 Chrome 的功能会相对落后但较稳定。所以，Chromium 和 Chrome 都是浏览器，Chromium 是开发版本，相比起 Chrome 更新速度快很多，有时数个小时就有一个新版本，不过普通人一般用 Chrome 就可以了。补充：为什么要搞一个新的 Blink 内核Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支。Google 的 Chromium 项目此前一直使用 WebKit(WebCore) 作为渲染引擎。后来，由于苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Chromium 一直停留在 WebKit，并使用移植的方式来实现和主线 WebKit2 的对接。这增加了 Chromium 的复杂性，且在一定程度上影响了 Chromium 的架构移植工作。基于以上原因，Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发），将在 WebKit 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 WebKit 的影响，创造一个完全独立的 Blink 引擎。EdgeHTML 内核Windows10后，IE内置浏览器 Edge 使用的内核。JS引擎为 Chakra 。使用该内核的浏览器：Edge。国内其他浏览器上面说到的5大主流浏览器(IE，Edge，Opera，Safari，Firefox，Chrome)，都是单核浏览器。相比较，国内很多浏览器则是双核或多核。即由1个 Trident + N个其他核心 组成的。常见的国内浏览器核心如下：360安全浏览器（1.0-5.0为 Trident，6.0为 Trident+Webkit ，7.0为 Trident+Blink ）360极速浏览器（7.5之前为 Trident+Webkit ，7.5为 Trident+Blink）猎豹安全浏览器（1.0-4.2版本为 Trident+Webkit，4.3及以后版本为 Trident+Blink）傲游浏览器（傲游1.x、2.x为 Trident，3.x为 Trident+Webkit）世界之窗浏览器（最初为 Trident，2013年采用 Trident+Chromium）搜狗高速浏览器（1.x为 Trident，2.0及以后版本为 Trident+Webkit）UC浏览器（ Blink+Trident）对于多核浏览器，Trident 指 兼容模式，而 其他内核 指 高速浏览模式 。最后参考文章：1. 浏览器内核-渲染引擎、js引擎2. 五大主流浏览器与四大内核3. 聊聊浏览器内核]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个Linux命令]]></title>
    <url>%2F2019%2F05%2F16%2FLinux-Command%2F</url>
    <content type="text"><![CDATA[最近在学一个系列，每天一个 Linux 命令由于之前的笔记是写在 旧版博客 上的所以这里就不重新整理一份了，hahaha ~直接，传送门(๑•̀ㅂ•́)و✧]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 hexo 的一次踩坑之旅]]></title>
    <url>%2F2019%2F05%2F14%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[关于 hexo 的一次踩坑之旅。之前一直是在自己搭的网站写博客，markdown写好后用编辑器转成 html 格式，然后直接扔上去。emmmmm… 巨丑。后来决定弄个漂亮点的博客，研究了下，决定用 hexo + github 来部署。看完文档感觉挺简单，结果花了几天时间才弄好，中间也碰到几个坑，记录一下。npm 权限问题因为之前安装 node 的时候自动安装了 npm ， 然后 Mac 下 npm 是默认安装在 /usr/local/ 路径下的，而该路径下很多目录和文件时 只读的 ，然后在安装 hexo 的时候，会报权限错误；12// 此处会报权限错误npm install -g hexo-cli解决方法网上找了一下，主要有四种解决方法：方法一为当前用户添加 npm安装目录 下所有文件的写权限。1sudo chown -R (whoami)(npm config get prefix)/&#123;lib/node_modules,bin,share&#125;注意 ：如果路径是 /usr/local/ 的话不推荐这种方式，因为改权限会弄乱系统的权限，以后可能导致奇怪的错误(比如无法跟当前系统的其他用户共享)。方法二把 npm 卸载，并安装在一个有读写权限的路径下；推荐 ~/.npm-global 路径下；1.新建一个全局安装的路径；1mkdir ~/.npm-global2.配置 npm 使用新的路径；1npm config set prefix '~/.npm-global'3.打开或者新建 ~/.profile ，加入下面一行；1export PATH=~/.npm-global/bin:$PATH4.重新启动终端；1source ~/.profile5.测试：安装一个全局包试试12345npm install -g jslint[luncher@localhost aaa]$ ls ~/.npm-global/bin/jshint[luncher@localhost aaa]$方法三(推荐)使用 nvm 。nvm 可以在一台电脑上管理不同版本的 node，并且使用 nvm 安装 npm 后，npm 默认的安装路径是有读写权限的，也就是说，以后 npm 安装任何包都不用再使用 sudo 参数了。官网的解决方案：https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally；这里有个细节要注意：如果你本地已经安装了npm，你得先把本地的npm卸载，再安装nvm，再使用nvm安装npm；1.卸载已安装到全局的 node/npmnode 命令在 /usr/local/bin/node，npm 命令在 /usr/local/lib/node_modules/npm 下；查看已经安装的全局模块，以便卸载后再按不同的 node 版本重新安装；1npm ls -g --depth=0123sudo rm -rf /usr/local/lib/node_modules #删除全局 node_modules 目录sudo rm /usr/local/bin/node #删除 nodecd /usr/local/bin &amp;&amp; ls -l | grep "../lib/node_modules/" | awk '&#123;print $9&#125;'| xargs rm #删除全局 node 模块注册的软链2.安装 nvm1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash方法四借助第三方工具安装 nodemac 系统借助 brew 安装 node1brew install nodecentos 系统借助 yum 安装 node1yum install node部署分支问题由于 hexo 部署(hexo d) 的原理是，把站点上的所有静态文件删除，并把本地待部署的全部静态站点文件(/public/目录下) push 到远程库上，即完全覆盖；所以 hexo 官方文档有这样一句话 建议使用 master 作为写作分支，新建一个 public 分支作为发布分支。在按照这样创建分支后，发现网站打不开，然后在 github pages 的文档里看到这样几句话：Reponsitory 必须以 username.github.io 命令，这个 username 为 github 的账户名，网站部署成功后，使用 https://username.github.io 进行访问；必须使用 master 分支管理网站静态文件。注意这句话，必须使用 master 分支。emmmmm….. 就是这么坑。所以，github的建议是：使用 master 作为发布分支，使用 hexo 作为写作分支。Hexo 的使用Hexo 的使用流程一般如下：官方文档1.安装 hexo1npm install -g hexo-cli2.创建 项目123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install3.新建 文章1hexo new [layout] &lt;title&gt;4.生成静态文件123hexo g// orhexo generate5.本地预览123hexo s// or hexo server6.部署到服务器123hexo d// or hexo deploy关于主题主题的使用很简单，以下几个步骤即可：1.clone 主题到本地12cd your_blog_dirgit clone https://github.com/DIYgod/hexo-theme-sagiri.git themes/sagiri2.修改 hexo 配置文件使用主题12## Themes: https://hexo.io/themes/theme: sagiri3.修改 主题配置文件，进行个性化设置1// 路径为：your_blog_dir/themes/sagiri/_config.yml推荐主题搜集了一些比较好看的主题：sagiri ：https://diygod.meMaterial X ：https://xaoxuu.comInside ：https://blog.oniuo.comNext ：https://blog.tolvyou.cn旧版博客最后，就是巨丑的旧版博客了…….]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>web前端</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搬家啦]]></title>
    <url>%2F2019%2F05%2F13%2FMigrate-Blog%2F</url>
    <content type="text"><![CDATA[博客搬家啦新博客使用 hexo + github pages 来搭建关于旧博客，对，就是巨丑的那个 ~~点我！点我就能看 ….(づ｡◕‿‿◕｡)づ————————– 分 割 线 ————————–补充一下由于旧博客不是用 博客框架 ( Hexo，Jekyll，Wordpress )搭建的所以很多文章不是用 markdown 写的，部分用 markdown 写的文章也由于内容太长然后，迁移起来就比较麻烦…o(╯□╰)o所以，就直接给个链接代替了..hahaha ~]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
